<!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="UTF-8">
  <title>Stella Obasan: Vector Patrol</title>
  <style>
    html,body { margin:0; background:#000; color:#0ff; font-family:"Courier New",monospace; }
    canvas { display:block; width:100vw; height:100vh; }
    #overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:#0ff; }
    #hud { position:absolute; bottom:12px; left:12px; font-size:14px; line-height:1.4; }
    #message { position:absolute; top:40%; width:100%; text-align:center; font-size:32px; letter-spacing:4px; }
  </style>
  </head>
  <body>
  <canvas id="screen"></canvas>
  <div id="overlay">
    <div id="hud"></div>
    <div id="message"></div>
  </div>
  <script>
  (() => {
    const canvas = document.getElementById("screen");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hud");
    const message = document.getElementById("message");
    const state = {
      running: true,
      enemies: [],
      lasers: [],
      explosions: [],
      stars: [],
      inputs: {},
      speed: 50,
      shield: 100,
      score: 0,
      roll: 0,
      yaw: 0,
      pitch: 0,
      lastTime: 0,
      timeSinceStart: 0,
      zoneSpawnIndex: 0,
      enemyShots: [],
      debugMode: false,
      loopCount: 0,
      messageTimer: 0,
      formations: {}
    };
    const settings = {
      starCount: 120,
      fov: 400,
      enemyRetreatBase: 32,
      formationRetreatBase: 30,
      maxApproachRate: 34,
      enemyRecedeFactor: 0.45,
      maxShield: 100,
      minSpeed: 20,
      maxSpeed: 120,
      agilityBase: 60,
      agilityQuick: 110,
      rollReturn: 4,
      rollYawInfluence: 0.5,
      rollVisualFactor: 0.02
    };
    const stageConfig = {
      battleships: 1,
      escortsPerShip: 2,
      fighterWaves: 3,
      fightersPerWave: 5,
      dreadnoughtEscorts: 4
    };
    const enemyFireSettings = {
      minDelay: 2.5,
      maxDelay: 5.5,
      blindCone: 52,
      verticalCone: 22,
      behindThreshold: 18,
      fireChance: 0.25
    };
    const stageZones = [
      { label: "初動", baseZ: 300, startDelay: 4, fighterWaves: 2, fightersPerWave: 8, waveInterval: 11 },
      { label: "増援", baseZ: 255, startDelay: 8, fighterWaves: 2, fightersPerWave: 7, corvettes: 2, waveInterval: 14 },
      { label: "中盤", baseZ: 220, startDelay: 12, fighterWaves: 1, fightersPerWave: 6, corvettes: 4, waveInterval: 16 },
      {
        label: "決戦",
        baseZ: 190,
        startDelay: 18,
        fighterWaves: 2,
        fightersPerWave: 5,
        corvettes: 6,
        battleships: true,
        waveInterval: 18,
        battleSpacing: 24
      },
      {
        label: "旗艦",
        baseZ: 150,
        startDelay: 26,
        fighterWaves: 1,
        fightersPerWave: 8,
        corvettes: 4,
        dreadnought: true,
        dreadnoughtEscorts: 6,
        waveInterval: 14
      }
    ];

  function init() {
  resize();
  window.addEventListener("resize", resize);
  window.addEventListener("keydown", e => {
  state.inputs[e.key.toLowerCase()] = true;
  if (!state.running && e.key.toLowerCase() === "r") resetGame();
  if (e.key === "F1") toggleDebugMode();
  });
  window.addEventListener("keyup", e => state.inputs[e.key.toLowerCase()] = false);
  createStars();
  resetGame();
  requestAnimationFrame(loop);
  }

  function resetGame() {
  state.running = true;
  state.enemies = [];
  state.lasers = [];
  state.explosions = [];
  state.speed = 50;
  state.shield = settings.maxShield;
  state.score = 0;
  message.textContent = "";
  state.messageTimer = 0;
  setupStage();
  }

  function createStars() {
  state.stars = [];
  for (let i = 0; i < settings.starCount; i++) {
  state.stars.push({
  x: (Math.random() - 0.5) * 200,
  y: (Math.random() - 0.5) * 200,
  z: Math.random() * 200 + 50
  });
  }
  }

  function setupStage() {
    // スタート時には敵を持たない状態にし、タイマーで順次湧かせる
    state.enemies = [];
    state.timeSinceStart = 0;
    state.zoneSpawnIndex = 0;
    state.running = true;
    state.formations = {};
  }

  function showMessage(text, duration = 3) {
    message.textContent = text;
    state.messageTimer = duration;
  }

  function handleSpawnTimer() {
    while (state.zoneSpawnIndex < stageZones.length) {
      const zone = stageZones[state.zoneSpawnIndex];
      if (state.timeSinceStart < zone.startDelay) break;
      state.zoneSpawnIndex += 1;
      spawnZoneFighters(zone);
      if (zone.corvettes) spawnZoneCorvettes(zone);
      if (zone.battleships) spawnZoneBattleships(zone);
      if (zone.dreadnought) spawnZoneDreadnought(zone);
    }
  }

  function updateFormationAnchors(dt) {
    const targetX = state.yaw * 3;
    const targetY = -state.pitch * 1.5;
    const anchorRetreat = settings.formationRetreatBase ?? settings.enemyRetreatBase;
    const relativeForward = state.speed - anchorRetreat;
    Object.keys(state.formations).forEach(id => {
      const formation = state.formations[id];
      formation.anchorX += (targetX - formation.anchorX) * dt * 1.6;
      formation.anchorY += (targetY - formation.anchorY) * dt * 1.2;
      if (relativeForward > 0) {
        const approach = Math.min(relativeForward, settings.maxApproachRate);
        formation.anchorZ -= approach * dt;
      } else if (relativeForward < 0) {
        const recede = Math.min(anchorRetreat, -relativeForward) * settings.enemyRecedeFactor;
        formation.anchorZ += recede * dt;
      }
      if (formation.members <= 0) {
        delete state.formations[id];
      }
    });
  }

  function releaseFormationSlot(enemy) {
    if (!enemy.formationGroup) return;
    const formation = state.formations[enemy.formationGroup];
    if (!formation) return;
    formation.members = Math.max(0, formation.members - 1);
  }

  function loopStage() {
    state.loopCount += 1;
    state.lasers = [];
    state.enemyShots = [];
    state.explosions = [];
    setupStage();
    showMessage(`STAGE MAP LOOP ${state.loopCount}`, 1.8);
  }

  function spawnZoneFighters(zone) {
    const interval = zone.waveInterval || 18;
    const perGroup = 3;
    for (let wave = 0; wave < zone.fighterWaves; wave++) {
      const waveZ = zone.baseZ - wave * interval;
      const groups = Math.ceil(zone.fightersPerWave / perGroup);
      for (let g = 0; g < groups; g++) {
        const groupId = `fg_${Date.now()}_${Math.random().toString(36).slice(2,5)}`;
        state.formations[groupId] = {
          anchorX: 0,
          anchorY: 0,
          anchorZ: waveZ,
          members: 0
        };
        for (let r = 0; r < perGroup; r++) {
          const index = g * perGroup + r;
          if (index >= zone.fightersPerWave) break;
          const offsetX = (r - 1) * 6 + (g - groups / 2) * 8;
          const offsetY = (r - 1) * 3;
          const fighter = createFighter(
            offsetX + (Math.random() - 0.5) * 4,
            offsetY + (Math.random() - 0.5) * 6,
            waveZ + (Math.random() - 0.5) * 6
          );
          fighter.formationGroup = groupId;
          fighter.formationOffset = { x: offsetX, y: offsetY };
          state.formations[groupId].members += 1;
          state.enemies.push(fighter);
        }
      }
    }
  }

  function spawnZoneCorvettes(zone) {
    const distanceStep = 6;
    for (let i = 0; i < zone.corvettes; i++) {
      const offsetX = (Math.random() - 0.5) * 30;
      const offsetY = (Math.random() - 0.5) * 20;
      const offsetZ = zone.baseZ - i * distanceStep;
      state.enemies.push(createEscort(offsetX, offsetY, offsetZ));
    }
  }

  function spawnZoneBattleships(zone) {
    const spacing = zone.battleSpacing || 22;
    for (let i = 0; i < stageConfig.battleships; i++) {
      const lane = i - (stageConfig.battleships - 1) / 2;
      const baseX = lane * 26;
      const baseY = (Math.random() - 0.5) * 32;
      const baseZ = zone.baseZ - i * spacing;
      const ship = createBattleship(baseX, baseY, baseZ);
      state.enemies.push(ship);
      const escorts = zone.escortsPerShip ?? stageConfig.escortsPerShip;
      for (let e = 0; e < escorts; e++) {
        const offsetX = baseX + (e % 2 === 0 ? -10 : 10);
        const offsetY = baseY + (e === 0 ? -6 : 6);
        const offsetZ = baseZ + 10 + e * 4;
        state.enemies.push(createEscort(offsetX, offsetY, offsetZ));
      }
    }
  }

  function spawnZoneDreadnought(zone) {
    const baseX = 0;
    const baseY = (Math.random() - 0.5) * 14;
    const baseZ = zone.baseZ || 150;
    const dread = createDreadnought(baseX, baseY, baseZ);
    state.enemies.push(dread);
    const escorts = zone.dreadnoughtEscorts ?? stageConfig.dreadnoughtEscorts;
    for (let i = 0; i < escorts; i++) {
      const angle = (Math.PI * 2 * i) / escorts;
      const radius = 22 + (i % 2) * 5;
      const offsetX = baseX + Math.cos(angle) * radius;
      const offsetY = baseY + Math.sin(angle) * radius * 0.6;
      const offsetZ = baseZ + 8 + i * 3;
      state.enemies.push(createEscort(offsetX, offsetY, offsetZ));
    }
    showMessage("FLAGSHIP DETECTED - DESTROY CORE", 4.5);
  }

  function createFighter(x, y, z) {
  return {
  type: "fighter",
  x: x ?? (Math.random() - 0.5) * 120,
  y: y ?? (Math.random() - 0.5) * 80,
  z: z ?? 320,
  vx: (Math.random() - 0.5) * 4,
  vy: (Math.random() - 0.5) * 4,
  retreatSpeed: settings.enemyRetreatBase + Math.random() * 6,
  maxApproachRate: settings.maxApproachRate + Math.random() * 2,
  flash: 0,
  fireTimer: Math.random() * enemyFireSettings.maxDelay,
  fireDelay: enemyFireSettings.minDelay + Math.random() * (enemyFireSettings.maxDelay - enemyFireSettings.minDelay),
  retired: false,
  pendingExplosion: false,
  pendingExplosionColor: "#f0f",
  pendingExplosionScore: 100,
  pendingMegaExplosion: false,
  megaExplosionHandler: null,
  scoreAwarded: false
  };
  }

  function createEscort(x, y, z) {
  return {
  type: "corvette",
  x,
  y,
  z,
  vx: (Math.random() - 0.5) * 3,
  vy: (Math.random() - 0.5) * 3,
  retreatSpeed: settings.enemyRetreatBase - 2 + Math.random() * 4,
  maxApproachRate: settings.maxApproachRate - 2 + Math.random() * 2,
  recedeFactor: settings.enemyRecedeFactor,
  phase: Math.random() * Math.PI * 2,
  flash: 0,
  fireTimer: Math.random() * enemyFireSettings.maxDelay,
  fireDelay: enemyFireSettings.minDelay + Math.random() * (enemyFireSettings.maxDelay - enemyFireSettings.minDelay),
  retired: false,
  pendingExplosion: false,
  pendingExplosionColor: "#0f9",
  pendingExplosionScore: 150,
  pendingMegaExplosion: false,
  megaExplosionHandler: null,
  scoreAwarded: false
  };
  }

  function createBattleship(baseX, baseY, baseZ) {
  const segments = [];
  const segmentCount = 4;
  const spacing = 16;
  for (let i = 0; i < segmentCount; i++) {
  segments.push({
  offsetX: (Math.random() - 0.5) * 4,
  offsetY: (Math.random() - 0.5) * 3,
  offsetZ: i * spacing,
  destroyed: false,
  hp: 2 + Math.floor(Math.random() * 3),
  size: i === 0 ? 11 : 9
  });
  }
  return {
  type: "battleship",
  x: baseX ?? (Math.random() - 0.5) * 100,
  y: baseY ?? (Math.random() - 0.5) * 60,
  z: baseZ ?? 340,
  retreatSpeed: 24 + Math.random() * 4,
  maxApproachRate: 26,
  recedeFactor: 0.38,
  vx: (Math.random() - 0.5) * 4,
  vy: (Math.random() - 0.5) * 3,
  flash: 0,
  segments
  ,
  fireTimer: Math.random() * enemyFireSettings.maxDelay,
  fireDelay: enemyFireSettings.minDelay + Math.random() * (enemyFireSettings.maxDelay - enemyFireSettings.minDelay),
  retired: false,
  pendingExplosion: false,
  pendingExplosionColor: "#fff",
  pendingExplosionScore: 200,
  pendingMegaExplosion: false,
  megaExplosionHandler: null,
  scoreAwarded: false,
  explosionDelay: 0,
  cumulativeDamage: 0,
  damageThreshold: segmentCount * 45
  };
  }

  function createDreadnought(baseX, baseY, baseZ) {
    const blueprint = [
      { key: "engineL", offsetX: -18, offsetY: 5, offsetZ: -24, hp: 3, size: 12, score: 200, turret: true, fireDelay: 2.8 },
      { key: "engineR", offsetX: 18, offsetY: 5, offsetZ: -24, hp: 3, size: 12, score: 200, turret: true, fireDelay: 2.8 },
      { key: "hangar", offsetX: 0, offsetY: 9, offsetZ: -8, hp: 4, size: 14, score: 260, turret: true, fireDelay: 2.4 },
      { key: "shield", offsetX: 0, offsetY: 0, offsetZ: -4, hp: 4, size: 15, score: 280, generator: true },
      { key: "bridge", offsetX: 0, offsetY: -6, offsetZ: 10, hp: 3, size: 12, score: 320, requires: ["shield"], turret: true, fireDelay: 3.2 },
      { key: "core", offsetX: 0, offsetY: 0, offsetZ: 22, hp: 5, size: 10, score: 900, requires: ["engineL", "engineR", "hangar", "bridge"], final: true }
    ];
    const segments = blueprint.map(seg => ({
      ...seg,
      destroyed: false
    }));
    const segmentMap = {};
    for (const segment of segments) {
      segmentMap[segment.key] = segment;
    }
    return {
      type: "dreadnought",
      x: baseX ?? (Math.random() - 0.5) * 40,
      y: baseY ?? (Math.random() - 0.5) * 24,
      z: baseZ ?? 360,
      vx: 0,
      vy: 0,

      retreatSpeed: 18,
      maxApproachRate: 20,
      recedeFactor: 0.32,

      flash: 0,
      segments,
      segmentMap,
      fireTimer: 0,
      fireDelay: 3,
      turretTimers: {},
      retired: false,
      pendingExplosion: false,
      pendingExplosionColor: "#fff",
      pendingExplosionScore: 900,
      pendingMegaExplosion: false,
      megaExplosionHandler: null,
      scoreAwarded: false,
      explosionDelay: 0,
      driftPhase: Math.random() * Math.PI * 2,
      coreAnnounced: false
    };
  }

  function handleInput(dt) {
  // 入力状態から機体姿勢と速度を更新
  const a = state.inputs;
  const agility = a["shift"] ? settings.agilityQuick : settings.agilityBase;
  const turnSpeed = agility * dt;
  const yawDir = (a["arrowleft"] || a["a"]) ? 1 : (a["arrowright"] || a["d"]) ? -1 : 0;
  const pitchDir = (a["arrowup"] || a["w"]) ? 1 : (a["arrowdown"] || a["s"]) ? -1 : 0;
  const manualRoll = (a["q"] ? 1 : 0) - (a["e"] ? 1 : 0);
  const rollTarget = yawDir * 30 + manualRoll * 25;
  state.roll += (rollTarget - state.roll) * dt * settings.rollReturn;
  if (yawDir !== 0) {
    state.yaw += (turnSpeed + Math.abs(state.roll) * 0.005) * yawDir;
  }
  state.yaw += state.roll * settings.rollYawInfluence * dt;
  if (pitchDir !== 0) {
    state.pitch += turnSpeed * pitchDir;
  }
  if (a["shift"]) state.speed = Math.min(settings.maxSpeed, state.speed + 60 * dt);
  else if (a["control"]) state.speed = Math.max(settings.minSpeed, state.speed - 60 * dt);
  if (a[" "]) {
  fireLaser();
  a[" "] = false;
  }
  }

  function fireLaser() {
  const baseVz = state.speed + 120;
  const offsets = [-3.5, 3.5];
  offsets.forEach(offset => {
    state.lasers.push({
      x: state.yaw * 0.2 + offset,
      y: -state.pitch * 0.2,
      z: 10,
      vz: baseVz
    });
  });
  }

  function toggleDebugMode() {
  state.debugMode = !state.debugMode;
  if (state.debugMode) {
    state.shield = settings.maxShield;
  }
  }

  function spawnExplosion(x, y, z, color, count) {
  // ワイヤーフレーム風の飛散粒子を生成
  for (let i = 0; i < count; i++) {
    const speed = 40 + Math.random() * 60;
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.random() * Math.PI;
  const vx = Math.cos(theta) * Math.sin(phi) * speed;
  const vy = Math.sin(theta) * Math.sin(phi) * speed;
  const vz = Math.cos(phi) * speed;
      state.explosions.push({
        x,
        y,
        z,
        vx,
        vy,
        vz,
        life: 0.6 + Math.random() * 0.4,
        color
      });
    }
  }

  function spawnLingeringExplosion(x, y, z, color) {
    const count = 30;
    for (let i = 0; i < count; i++) {
      const speed = 6 + Math.random() * 4;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const vx = Math.cos(theta) * Math.sin(phi) * speed * 0.2;
      const vy = Math.sin(theta) * Math.sin(phi) * speed * 0.2;
      const vz = Math.cos(phi) * speed * 0.3;
      state.explosions.push({
        x,
        y,
        z,
        vx,
        vy,
        vz,
        life: 1.2 + Math.random() * 0.6,
        color
      });
    }
  }

  function spawnShieldSpark(x, y, z, color = "#0ff") {
    for (let i = 0; i < 14; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 20 + Math.random() * 40;
      state.explosions.push({
        x,
        y,
        z,
        vx: Math.cos(angle) * speed * 0.04,
        vy: Math.sin(angle) * speed * 0.04,
        vz: (Math.random() - 0.5) * speed * 0.08,
        life: 0.2 + Math.random() * 0.25,
        color
      });
    }
  }

  function queueDelayedExplosion(enemy, { delay = 0.6, color = "#fff", score = 0, mega = false, megaHandler = null } = {}) {
    if (enemy.pendingExplosion) return;
    enemy.dead = true;
    enemy.pendingExplosion = true;
    enemy.explosionDelay = delay;
    enemy.pendingExplosionColor = color;
    enemy.pendingExplosionScore = score;
    enemy.pendingMegaExplosion = Boolean(mega);
    enemy.megaExplosionHandler = megaHandler;
    enemy.flash = 0.6;
    enemy.scoreAwarded = false;
  }

  function queueBattleshipExplosion(enemy) {
    queueDelayedExplosion(enemy, { delay: 0.75, color: "#fff", score: 200, mega: true });
  }

  function queueDreadnoughtExplosion(enemy) {
    queueDelayedExplosion(enemy, { delay: 1.3, color: "#fff", score: 1200, mega: true, megaHandler: spawnDreadnoughtCataclysm });
    showMessage("FLAGSHIP NEUTRALIZED", 4.2);
  }

  function applyBattleshipSegmentDamage(enemy, segment, segPos) {
    if (segment.destroyed) return;
    segment.hp = Math.max(0, (segment.hp ?? 1) - 1);
    enemy.cumulativeDamage += 40;
    enemy.flash = 0.2;
    state.score += 120;
    spawnExplosion(segPos.x, segPos.y, segPos.z, "#0ff", segment.hp > 0 ? 10 : 20);
    if (segment.hp <= 0) {
      segment.destroyed = true;
    }
    if (enemy.cumulativeDamage >= enemy.damageThreshold && !enemy.pendingExplosion) {
      enemy.dead = true;
      queueBattleshipExplosion(enemy);
    }
  }

  function applyDreadnoughtSegmentDamage(enemy, segment, segPos) {
    if (segment.destroyed) return;
    if (isSegmentLocked(enemy, segment)) {
      spawnShieldSpark(segPos.x, segPos.y, segPos.z, "#0ff");
      enemy.flash = 0.12;
      return;
    }
    const maxScore = segment.score ?? 400;
    const partialScore = Math.max(80, Math.floor(maxScore * 0.25));
    const wasFinalHit = (segment.hp ?? 1) <= 1;
    segment.hp = Math.max(0, (segment.hp ?? 1) - 1);
    enemy.flash = 0.25;
    const color = segment.generator ? "#0ff" : segment.final ? "#fff" : "#0ff";
    spawnExplosion(segPos.x, segPos.y, segPos.z, color, wasFinalHit ? 28 : 16);
    if (segment.hp <= 0) {
      segment.destroyed = true;
      state.score += maxScore;
      spawnLingeringExplosion(segPos.x, segPos.y, segPos.z, color);
      if (segment.generator) {
        showMessage("SHIELD GENERATOR DOWN", 3.2);
      }
      if (segment.final) {
        queueDreadnoughtExplosion(enemy);
      } else {
        const core = enemy.segmentMap?.core;
        if (core && !core.destroyed && !isSegmentLocked(enemy, core) && !enemy.coreAnnounced) {
          enemy.coreAnnounced = true;
          showMessage("CORE EXPOSED - FINISH IT", 3.8);
        }
      }
    } else {
      state.score += partialScore;
    }
  }

  function spawnBattleshipMegaExplosion(enemy) {
    // 爆発の粒子を多めに、ゆっくり広がるように
    const colorCycle = ["#fff", "#0ff", "#f88"];
    const center = { x: enemy.x, y: enemy.y, z: enemy.z };
    for (let i = 0; i < 55; i++) {
      const speed = 12 + Math.random() * 20;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const vx = Math.cos(theta) * Math.sin(phi) * speed;
      const vy = Math.sin(theta) * Math.sin(phi) * speed;
      const vz = Math.cos(phi) * speed * 0.4;
      state.explosions.push({
        x: center.x,
        y: center.y,
        z: center.z,
        vx,
        vy,
        vz,
        life: 0.8 + Math.random() * 0.8,
        color: colorCycle[i % colorCycle.length]
      });
    }
    spawnExplosion(center.x, center.y, center.z, "#fff", 20);
  }

  function spawnDreadnoughtCataclysm(enemy) {
    const center = { x: enemy.x, y: enemy.y, z: enemy.z };
    const ringColors = ["#fff", "#0ff", "#f88"];
    for (let ring = 0; ring < 3; ring++) {
      const count = 28 + ring * 18;
      const radius = 10 + ring * 9;
      const color = ringColors[ring % ringColors.length];
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = 28 + ring * 12 + Math.random() * 10;
        state.explosions.push({
          x: center.x + Math.cos(angle) * radius * 0.25,
          y: center.y + Math.sin(angle) * radius * 0.25,
          z: center.z + ring * 4,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          vz: (Math.random() - 0.5) * speed * 0.6,
          life: 1 + Math.random() * 1.2,
          color
        });
      }
    }
    spawnExplosion(center.x, center.y, center.z, "#fff", 40);
    spawnLingeringExplosion(center.x, center.y, center.z + 6, "#0ff");
  }

  // 敵が自機の前方にいて死角でないかを確認
  function canEnemyShoot(enemy) {
    return withinForwardConePosition(enemy);
  }

  function isEnemyVisible(enemy) {
    return isPositionVisible(enemy);
  }

  function withinForwardConePosition(position) {
    if (!position) return false;
    if (position.z < enemyFireSettings.behindThreshold) return false;
    if (Math.abs(position.x) > enemyFireSettings.blindCone) return false;
    if (Math.abs(position.y) > enemyFireSettings.verticalCone) return false;
    return true;
  }

  function isPositionVisible(position) {
    if (!position || position.z <= 10) return false;
    const proj = project(position);
    return proj.x > -40 && proj.x < canvas.width + 40 && proj.y > -40 && proj.y < canvas.height + 40;
  }

  // 後方からは発射せず、規定時間ごとにレーザーを射出
  function attemptEnemyFire(enemy, dt) {
    if (enemy.retired || enemy.pendingExplosion) return;
    if (enemy.type === "dreadnought") {
      attemptDreadnoughtFire(enemy, dt);
      return;
    }
    enemy.fireTimer += dt;
    if (enemy.fireTimer < enemy.fireDelay) return;
    enemy.fireTimer = 0;
    if (!canEnemyShoot(enemy)) return;
    if (!isEnemyVisible(enemy)) return;
    if (Math.random() > enemyFireSettings.fireChance) return;
    const dir = aimAtPlayer(enemy);
    const speed = 25 + Math.random() * 10;
    state.enemyShots.push({
      x: enemy.x,
      y: enemy.y,
      z: enemy.z - 6,
      vx: dir.x * speed,
      vy: dir.y * speed,
      vz: dir.z * speed,
      done: false
    });
  }

  function aimAtPlayer(enemy) {
    return aimFromPoint(enemy);
  }

  function aimFromPoint(point) {
    const dx = -point.x;
    const dy = -point.y;
    const dz = -point.z;
    const mag = Math.hypot(dx, dy, dz) || 0.0001;
    return { x: dx / mag, y: dy / mag, z: dz / mag };
  }

  function attemptDreadnoughtFire(enemy, dt) {
    enemy.turretTimers = enemy.turretTimers || {};
    for (const segment of enemy.segments) {
      if (!segment.turret || segment.destroyed) continue;
      if (isSegmentLocked(enemy, segment)) continue;
      const segPos = segmentWorldPosition(enemy, segment);
      if (!withinForwardConePosition(segPos)) continue;
      if (!isPositionVisible(segPos)) continue;
      enemy.turretTimers[segment.key] = (enemy.turretTimers[segment.key] || 0) + dt;
      const delay = segment.fireDelay || enemy.fireDelay || 3.2;
      if (enemy.turretTimers[segment.key] < delay) continue;
      enemy.turretTimers[segment.key] = Math.random() * 0.8;
      if (Math.random() > 0.65) continue;
      const dir = aimFromPoint(segPos);
      const speed = 22 + Math.random() * 12;
      state.enemyShots.push({
        x: segPos.x,
        y: segPos.y,
        z: segPos.z - 6,
        vx: dir.x * speed,
        vy: dir.y * speed,
        vz: dir.z * speed,
        done: false
      });
    }
  }
  function resetBattleshipSegments(enemy) {
  if (!enemy.segments) return;
  enemy.segments.forEach(seg => seg.destroyed = false);
  }

  function segmentWorldPosition(enemy, segment) {
  return {
  x: enemy.x + (segment.offsetX || 0),
  y: enemy.y + (segment.offsetY || 0),
  z: enemy.z + (segment.offsetZ || 0)
  };
  }

  function isSegmentLocked(enemy, segment) {
    if (!segment?.requires || !enemy?.segmentMap) return false;
    return segment.requires.some(key => {
      const req = enemy.segmentMap[key];
      return req && !req.destroyed;
    });
  }

  function update(dt) {
  if (!state.running) return;
  if (state.messageTimer > 0) {
    state.messageTimer -= dt;
    if (state.messageTimer <= 0) {
      message.textContent = "";
    }
  }
  state.timeSinceStart += dt;
  updateFormationAnchors(dt);
  handleSpawnTimer();
  handleInput(dt);
      // 星を移動させて疑似的な速度感を演出
      for (const star of state.stars) {
        star.z -= dt * state.speed * 0.6;
        if (star.z < 5) star.z += 200;
      }

      // プレイヤー姿勢で敵配置もゆっくり揺らし、追われる感覚を簡易再現
      for (const enemy of state.enemies) {
        enemy.age = (enemy.age || 0) + dt;

        const retreatSpeed = enemy.retreatSpeed ?? settings.enemyRetreatBase;
        const maxApproach = enemy.maxApproachRate ?? settings.maxApproachRate;
        const recedeFactor = enemy.recedeFactor ?? settings.enemyRecedeFactor;
        if (!enemy.pendingExplosion) {
          const relativeForward = state.speed - retreatSpeed;
          if (relativeForward > 0) {
            const approach = Math.min(relativeForward, maxApproach);
            enemy.z -= approach * dt;
          } else if (relativeForward < 0) {
            const recede = Math.min(retreatSpeed, -relativeForward) * recedeFactor;
            enemy.z += recede * dt;
          }
        }

        const formation = enemy.formationGroup ? state.formations[enemy.formationGroup] : null;
        if (formation && !enemy.pendingExplosion) {
          const targetX = formation.anchorX + (enemy.formationOffset?.x || 0);
          const targetY = formation.anchorY + (enemy.formationOffset?.y || 0);
          const dx = targetX - enemy.x;
          const dy = targetY - enemy.y;
          enemy.vx = dx * 3;
          enemy.vy = dy * 3;
        }
        enemy.x += dt * enemy.vx + state.yaw * dt * 0.4;
        enemy.y += dt * enemy.vy - state.pitch * dt * 0.4;
        if (enemy.z > 420 && !enemy.dead) {
          enemy.dead = true;
          enemy.retired = true;
          releaseFormationSlot(enemy);
          continue;
        }
        if (enemy.type === "corvette") {
          enemy.x += Math.sin(enemy.age * 1.8 + enemy.phase) * 6 * dt;
          enemy.y += Math.cos(enemy.age * 1.2 + enemy.phase) * 3 * dt;
        } else if (enemy.type === "dreadnought") {
          const sway = enemy.pendingExplosion ? 0 : 1;
          enemy.x += Math.sin(enemy.age * 0.35 + enemy.driftPhase) * dt * 8 * sway;
          enemy.y += Math.cos(enemy.age * 0.28 + enemy.driftPhase) * dt * 4 * sway;
        }
        if (enemy.pendingExplosion) {
          // 爆発までの遅延演出を進める
          enemy.explosionDelay -= dt;
          enemy.flash = Math.max(0, enemy.flash - dt);
          if (enemy.explosionDelay <= 0) {
            if (enemy.pendingMegaExplosion) {
              if (enemy.megaExplosionHandler) {
                enemy.megaExplosionHandler(enemy);
              } else {
                spawnBattleshipMegaExplosion(enemy);
              }
            } else {
              spawnLingeringExplosion(enemy.x, enemy.y, enemy.z, enemy.pendingExplosionColor || "#fff");
            }
            if (!enemy.scoreAwarded && enemy.pendingExplosionScore) {
              state.score += enemy.pendingExplosionScore;
              enemy.scoreAwarded = true;
            }
            enemy.retired = true;
            enemy.megaExplosionHandler = null;
            releaseFormationSlot(enemy);
          }
          continue;
        }
        attemptEnemyFire(enemy, dt);
        if (enemy.z < 5 && !enemy.dead) {
          const damage = enemy.type === "dreadnought" ? 40 : enemy.type === "battleship" ? 25 : enemy.type === "corvette" ? 12 : 6;
          if (!state.debugMode) state.shield -= damage;
          enemy.dead = true;
          enemy.retired = true;
          releaseFormationSlot(enemy);
          if (enemy.type === "dreadnought") {
            spawnDreadnoughtCataclysm(enemy);
          } else {
            const color = enemy.type === "battleship" ? "#fff" : "#f44";
            spawnExplosion(enemy.x, enemy.y, enemy.z, color, 18);
          }
        }
        if (enemy.flash > 0) enemy.flash -= dt;
      }

      // レーザー移動とヒット判定
      for (const laser of state.lasers) {
        laser.z += laser.vz * dt;
      }
      state.lasers = state.lasers.filter(l => l.z < 400 && !l.done);
      // 敵レーザーを移動させて自機に触れるか判定
      for (const shot of state.enemyShots) {
        shot.x += shot.vx * dt;
        shot.y += shot.vy * dt;
        shot.z += shot.vz * dt;
        if (shot.z < 5 && !shot.done) {
          shot.done = true;
          state.shield -= 8;
          spawnExplosion(shot.x, shot.y, shot.z, "#f44", 10);
        }
      }
      state.enemyShots = state.enemyShots.filter(shot => shot.z > -20 && !shot.done);
      // 爆発パーティクル更新
      for (const particle of state.explosions) {
        particle.life -= dt;
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        particle.z += particle.vz * dt;
      }
      state.explosions = state.explosions.filter(p => p.life > 0);

      // 3D距離しきい値で命中判定（簡易スフィア）
      for (const enemy of state.enemies) {
        for (const laser of state.lasers) {
          if (laser.done) continue;
          if (enemy.type === "dreadnought") {
            for (const segment of enemy.segments) {
              if (segment.destroyed) continue;
              const segPos = segmentWorldPosition(enemy, segment);
              const dx = segPos.x - laser.x;
              const dy = segPos.y - laser.y;
              const dz = segPos.z - laser.z;
              if (Math.abs(dz) < 18 && Math.hypot(dx, dy) < (segment.size + 3)) {
                applyDreadnoughtSegmentDamage(enemy, segment, segPos);
                laser.done = true;
                break;
              }
            }
          } else if (enemy.type === "battleship") {
            for (const segment of enemy.segments) {
              if (segment.destroyed) continue;
              const segPos = segmentWorldPosition(enemy, segment);
              const dx = segPos.x - laser.x;
              const dy = segPos.y - laser.y;
              const dz = segPos.z - laser.z;
              if (Math.abs(dz) < 16 && Math.hypot(dx, dy) < (segment.size + 2)) {
                applyBattleshipSegmentDamage(enemy, segment, segPos);
                laser.done = true;
                break;
              }
            }
          } else if (enemy.type === "corvette") {
            const dx = enemy.x - laser.x;
            const dy = enemy.y - laser.y;
            const dz = enemy.z - laser.z;
            if (Math.abs(dz) < 14 && Math.hypot(dx, dy) < 10) {
              enemy.flash = 0.2;
            enemy.dead = true;
            queueDelayedExplosion(enemy, { delay: 0.4, color: "#0f9", score: 150 });
            laser.done = true;
          }
          } else {
            const dx = enemy.x - laser.x;
            const dy = enemy.y - laser.y;
            const dz = enemy.z - laser.z;
            if (Math.abs(dz) < 12 && Math.hypot(dx, dy) < 6) {
              enemy.flash = 0.2;
            enemy.dead = true;
            queueDelayedExplosion(enemy, { delay: 0.35, color: "#f0f", score: 100 });
            laser.done = true;
          }
        }
      }
      }

      state.enemies = state.enemies.filter(enemy => !enemy.retired);
      if (state.enemies.length === 0 && state.zoneSpawnIndex >= stageZones.length) {
        loopStage();
        return;
      }

      if (state.shield <= 0 && !state.debugMode) {
        state.running = false;
        message.textContent = "MISSION FAILED - PRESS R";
      }

  }

  function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = 1;

      // 星のスキャンライン
      ctx.beginPath();
      for (const star of state.stars) {
        const p = project(star);
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + 1, p.y + 1);
      }
      ctx.stroke();

      // レーザーを細線で表示
      for (const laser of state.lasers) {
        drawPlayerLaser(laser);
      }
      // 敵レーザーの描画
      ctx.strokeStyle = "#f44";
      for (const shot of state.enemyShots) {
        const p = project(shot);
        ctx.beginPath();
        ctx.moveTo(p.x - 1, p.y);
        ctx.lineTo(p.x + 1, p.y);
        ctx.stroke();
      }

      // 敵ワイヤーフレーム（小型/大型）を描画
      for (const enemy of state.enemies) {
        if (enemy.type === "dreadnought") {
          drawDreadnought(enemy);
        } else if (enemy.type === "battleship") {
          drawBattleship(enemy);
        } else if (enemy.type === "corvette") {
          drawCorvette(enemy);
        } else {
          drawFighter(enemy);
        }
      }

      // 爆発パーティクルをベクタースタイルで描画
      for (const particle of state.explosions) {
        const tail = {
          x: particle.x - particle.vx * 0.015,
          y: particle.y - particle.vy * 0.015,
          z: particle.z - particle.vz * 0.015
        };
        const a = project(tail);
        const b = project(particle);
        ctx.strokeStyle = particle.color || "#fff";
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }

      // コクピット枠
      ctx.strokeStyle = "#0ff";
      ctx.beginPath();
      ctx.moveTo(0, canvas.height * 0.7);
      ctx.lineTo(canvas.width * 0.3, canvas.height);
      ctx.lineTo(canvas.width * 0.7, canvas.height);
      ctx.lineTo(canvas.width, canvas.height * 0.7);
      ctx.stroke();

      drawRotatedCrosshair();

      const hudLines = [];
      const shieldText = state.debugMode ? "∞" : Math.max(state.shield, 0);
      let baseLine = `SPEED ${state.speed.toFixed(0)}   SHIELD ${shieldText}   SCORE ${state.score}`;
      if (state.debugMode) baseLine += "   DEBUG MODE";
      hudLines.push(baseLine);
      const flagship = state.enemies.find(e => e.type === "dreadnought" && !e.retired);
      if (flagship) {
        const total = flagship.segments.length;
        const destroyed = flagship.segments.filter(seg => seg.destroyed).length;
        const locked = flagship.segments.filter(seg => !seg.destroyed && isSegmentLocked(flagship, seg)).length;
        const status = flagship.pendingExplosion
          ? "SCUTTLE"
          : locked > 0
            ? `LOCK ${locked}`
            : "CORE OPEN";
        hudLines.push(`FLAGSHIP ${destroyed}/${total}   ${status}`);
      }
      hud.textContent = hudLines.join("\n");

  }

  function drawFighter(enemy) {
  const color = enemy.flash > 0 ? "#fff" : "#f0f";
  withDepthRendering(enemy, color, () => {
    const points = [
      { x: enemy.x - 6, y: enemy.y, z: enemy.z + 8 },
      { x: enemy.x + 6, y: enemy.y, z: enemy.z + 8 },
      { x: enemy.x, y: enemy.y, z: enemy.z - 10 }
    ].map(p => project(p));
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    ctx.lineTo(points[1].x, points[1].y);
    ctx.lineTo(points[2].x, points[2].y);
    ctx.closePath();
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    ctx.lineTo(project({ x: enemy.x - 4, y: enemy.y - 2, z: enemy.z - 4 }).x, project({ x: enemy.x - 4, y: enemy.y - 2, z: enemy.z - 4 }).y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(points[1].x, points[1].y);
    ctx.lineTo(project({ x: enemy.x + 4, y: enemy.y - 2, z: enemy.z - 4 }).x, project({ x: enemy.x + 4, y: enemy.y - 2, z: enemy.z - 4 }).y);
    ctx.stroke();
    ctx.lineWidth = 1;
    drawWireCube({ x: enemy.x, y: enemy.y, z: enemy.z }, 5, color);
  });
  }

  function drawPlayerLaser(laser) {
    const front = project(laser);
    const tail = project({ x: laser.x, y: laser.y, z: laser.z - 16 });
    ctx.save();
    ctx.strokeStyle = "#6ef";
    ctx.lineWidth = 4;
    ctx.shadowColor = "#6ef";
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.moveTo(tail.x, tail.y);
    ctx.lineTo(front.x, front.y);
    ctx.stroke();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = "#0ff";
    ctx.beginPath();
    ctx.moveTo(tail.x, tail.y);
    ctx.lineTo(front.x, front.y);
    ctx.stroke();
    ctx.fillStyle = "#9ff";
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(front.x, front.y, 3.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawCorvette(enemy) {
  const color = enemy.flash > 0 ? "#fff" : "#0f9";
  withDepthRendering(enemy, color, () => {
    const hull = [];
    const length = 16;
    const width = 8;
    const height = 3;
    for (let i = 0; i < 6; i++) {
      const k = i / 5;
      hull.push({
        x: enemy.x + Math.sin(k * Math.PI) * width * 0.6,
        y: enemy.y + (i % 2 === 0 ? -height : height),
        z: enemy.z - length * (k - 0.5)
      });
    }
    ctx.beginPath();
    hull.forEach((p, idx) => {
      const proj = project(p);
      if (idx === 0) ctx.moveTo(proj.x, proj.y);
      else ctx.lineTo(proj.x, proj.y);
    });
    ctx.closePath();
    ctx.stroke();
    const bridge = project({ x: enemy.x, y: enemy.y - 2, z: enemy.z - 4 });
    const stern = project({ x: enemy.x, y: enemy.y, z: enemy.z + 6 });
    ctx.beginPath();
    ctx.moveTo(bridge.x, bridge.y);
    ctx.lineTo(stern.x, stern.y);
    ctx.stroke();
    drawWireCube({ x: enemy.x, y: enemy.y, z: enemy.z + 4 }, 4, color);
  });
  }

  function drawBattleship(enemy) {
  const color = enemy.flash > 0 ? "#fff" : "#0ff";
  withDepthRendering(enemy, color, () => {
    const hullLength = 20;
    const nose = project({ x: enemy.x, y: enemy.y, z: enemy.z - hullLength });
    const tail = project({ x: enemy.x, y: enemy.y, z: enemy.z + hullLength * 0.3 });
    ctx.beginPath();
    ctx.moveTo(nose.x, nose.y);
    ctx.lineTo(tail.x, tail.y);
    ctx.stroke();
    const wingLeft = project({ x: enemy.x - 12, y: enemy.y, z: enemy.z - 6 });
    const wingRight = project({ x: enemy.x + 12, y: enemy.y, z: enemy.z - 6 });
    ctx.beginPath();
    ctx.moveTo(wingLeft.x, wingLeft.y);
    ctx.lineTo(wingRight.x, wingRight.y);
    ctx.stroke();
    const deck = project({ x: enemy.x, y: enemy.y - 3, z: enemy.z });
    ctx.beginPath();
    ctx.arc(deck.x, deck.y, 6, 0, Math.PI * 2);
    ctx.stroke();
    const centers = [];
    for (const segment of enemy.segments) {
    if (segment.destroyed) continue;
    const pos = segmentWorldPosition(enemy, segment);
    centers.push(pos);
    drawGuideFrame(pos, segment.size || 9, color);
    }
    for (let i = 0; i < centers.length - 1; i++) {
    const a = project(centers[i]);
    const b = project(centers[i + 1]);
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
    }
  });
  }

  function drawDreadnought(enemy) {
  const color = enemy.flash > 0 ? "#fff" : "#0ff";
  withDepthRendering(enemy, color, () => {
    const prow = project({ x: enemy.x, y: enemy.y - 6, z: enemy.z - 34 });
    const stern = project({ x: enemy.x, y: enemy.y + 4, z: enemy.z + 22 });
    ctx.beginPath();
    ctx.moveTo(prow.x, prow.y);
    ctx.lineTo(stern.x, stern.y);
    ctx.stroke();
    const hullLeft = project({ x: enemy.x - 24, y: enemy.y + 6, z: enemy.z - 6 });
    const hullRight = project({ x: enemy.x + 24, y: enemy.y + 6, z: enemy.z - 6 });
    ctx.beginPath();
    ctx.moveTo(hullLeft.x, hullLeft.y);
    ctx.lineTo(prow.x, prow.y);
    ctx.lineTo(hullRight.x, hullRight.y);
    ctx.stroke();
    const keelLeft = project({ x: enemy.x - 18, y: enemy.y + 2, z: enemy.z + 12 });
    const keelRight = project({ x: enemy.x + 18, y: enemy.y + 2, z: enemy.z + 12 });
    ctx.beginPath();
    ctx.moveTo(keelLeft.x, keelLeft.y);
    ctx.lineTo(stern.x, stern.y);
    ctx.lineTo(keelRight.x, keelRight.y);
    ctx.stroke();
    const intactSegments = [];
    for (const segment of enemy.segments) {
      if (segment.destroyed) continue;
      const segPos = segmentWorldPosition(enemy, segment);
      const locked = isSegmentLocked(enemy, segment);
      const segColor = locked ? "#066" : color;
      drawGuideFrame(segPos, segment.size || 12, segColor);
      if (segment.final && !locked) {
        const center = project(segPos);
        const cross = (segment.size || 10) * 0.6;
        ctx.beginPath();
        ctx.moveTo(center.x - cross, center.y);
        ctx.lineTo(center.x + cross, center.y);
        ctx.moveTo(center.x, center.y - cross);
        ctx.lineTo(center.x, center.y + cross);
        ctx.stroke();
      }
      intactSegments.push({ pos: segPos, locked });
    }
    for (let i = 0; i < intactSegments.length - 1; i++) {
      const a = project(intactSegments[i].pos);
      const b = project(intactSegments[i + 1].pos);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }
  });
  }

  function drawGuideFrame(center, size, color) {
  drawWireCube(center, size, color);
  ctx.strokeStyle = color;
  ctx.beginPath();
  const left = project({ x: center.x - size * 0.6, y: center.y, z: center.z });
  const right = project({ x: center.x + size * 0.6, y: center.y, z: center.z });
  ctx.moveTo(left.x, left.y);
  ctx.lineTo(right.x, right.y);
  ctx.stroke();
  ctx.beginPath();
  const top = project({ x: center.x, y: center.y - size * 0.5, z: center.z });
  const bottom = project({ x: center.x, y: center.y + size * 0.5, z: center.z });
  ctx.moveTo(top.x, top.y);
  ctx.lineTo(bottom.x, bottom.y);
  ctx.stroke();
  }

  function drawWireCube(center, size, color) {
  const s = size;
  const verts = [
  [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
  [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]
  ].map(v => ({ x: center.x + v[0], y: center.y + v[1], z: center.z + v[2] }));
  drawWireShape(verts, [
  [0,1],[1,2],[2,3],[3,0],
  [4,5],[5,6],[6,7],[7,4],
  [0,4],[1,5],[2,6],[3,7]
  ], color);
  }

  function drawWireShape(verts, edges, color) {
  ctx.strokeStyle = color;
  ctx.beginPath();
  edges.forEach(([a,b]) => {
  const pa = project(verts[a]);
  const pb = project(verts[b]);
  ctx.moveTo(pa.x, pa.y);
  ctx.lineTo(pb.x, pb.y);
  });
  ctx.stroke();
  }

  function project(point) {
  // 3D座標→2D投影: x/z・y/z比に視野角を掛けてスクリーン中央に足す
  const scale = settings.fov / (point.z || 0.0001);
  return {
  x: canvas.width / 2 + point.x * scale,
  y: canvas.height / 2 + point.y * scale
  };
  }

  function depthEffect(enemy) {
  const depth = Math.min(420, Math.max(enemy.z, 20));
  const normalized = (depth - 20) / 400;
  const factor = 1 - normalized;
  const alpha = Math.min(1, Math.max(0.25, 0.35 + factor * 0.65));
  const width = 0.5 + factor * 1.8;
  return { alpha, width };
  }

  function withDepthRendering(enemy, color, drawFn) {
  const effect = depthEffect(enemy);
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = effect.width;
  ctx.globalAlpha = effect.alpha;
  drawFn();
  ctx.restore();
  }

  function drawRotatedCrosshair() {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const angle = -state.roll * settings.rollVisualFactor * Math.PI / 180;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-20, 0);
    ctx.lineTo(-5, 0);
    ctx.moveTo(20, 0);
    ctx.lineTo(5, 0);
    ctx.moveTo(0, -20);
    ctx.lineTo(0, -5);
    ctx.moveTo(0, 20);
    ctx.lineTo(0, 5);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  function loop(timestamp) {
  if (!state.lastTime) state.lastTime = timestamp;
  const dt = Math.min(0.033, (timestamp - state.lastTime) / 1000);
  state.lastTime = timestamp;
  update(dt);
  render();
  requestAnimationFrame(loop);
  }

  function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  }

  init();
  })();
  </script>
  </body>
  </html>

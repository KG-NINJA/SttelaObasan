<!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="UTF-8">
  <title>Stella Obasan: Vector Patrol</title>
  <style>
    html,body { margin:0; background:#000; color:#0ff; font-family:"Courier New",monospace; }
    canvas { display:block; width:100vw; height:100vh; }
    #overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:#0ff; }
    #hud { position:absolute; bottom:12px; left:12px; font-size:14px; line-height:1.4; white-space:pre; }
    #comms { position:absolute; top:12px; left:12px; font-size:12px; line-height:1.4; max-width:360px; color:#8ff; text-shadow:0 0 6px #0bf; white-space:pre-line; }
    #message { position:absolute; top:36%; width:100%; text-align:center; font-size:32px; letter-spacing:4px; }
  </style>
  </head>
  <body>
  <canvas id="screen"></canvas>
  <div id="overlay">
    <div id="comms"></div>
    <div id="hud"></div>
    <div id="message"></div>
  </div>
  <script>
  (() => {
    const canvas = document.getElementById("screen");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hud");
    const message = document.getElementById("message");
    const comms = document.getElementById("comms");
    const state = {
      running: true,
      enemies: [],
      lasers: [],
      explosions: [],
      shockwaves: [],
      chainReactions: [],
      stars: [],
      inputs: {},
      speed: 50,
      shield: 100,
      score: 0,
      roll: 0,
      yaw: 0,
      pitch: 0,
      lastTime: 0,
      timeSinceStart: 0,
      zoneSpawnIndex: 0,
      enemyShots: [],
      debugMode: false,
      loopCount: 0,
      messageTimer: 0,
      formations: {},
      navLog: [],
      chatterTimer: 0,
      nextChatter: 6,
      warpPhase: "entry",
      warpTimer: 0,
      warpIntensity: 0,
      sectorLabel: "LAGRANGE-3 / OBERON CORRIDOR",
      warpAnnounceDone: false
    };
    const settings = {
      starCount: 120,
      fov: 400,
      enemyRetreatBase: 32,
      formationRetreatBase: 30,
      maxApproachRate: 34,
      enemyRecedeFactor: 0.45,
      maxShield: 100,
      minSpeed: 20,
      maxSpeed: 120,
      agilityBase: 60,
      agilityQuick: 110,
      rollReturn: 4,
      rollYawInfluence: 0.5,
      rollVisualFactor: 0.02
    };
    const stageConfig = {
      battleships: 1,
      escortsPerShip: 1,
      fighterWaves: 2,
      fightersPerWave: 4,
      dreadnoughtEscorts: 4
    };
    const enemyFireSettings = {
      minDelay: 4.6,
      maxDelay: 8.2,
      blindCone: 52,
      verticalCone: 22,
      behindThreshold: 18,
      fireChance: 0.12
    };
    const explosionSettings = {
      extraDelay: 0.35
    };
    const stageZones = [
      { label: "初動", baseZ: 300, startDelay: 4, fighterWaves: 1, fightersPerWave: 6, waveInterval: 11 },
      { label: "増援", baseZ: 255, startDelay: 8, fighterWaves: 1, fightersPerWave: 6, corvettes: 1, waveInterval: 14 },
      { label: "中盤", baseZ: 220, startDelay: 12, fighterWaves: 1, fightersPerWave: 5, corvettes: 2, waveInterval: 16 },
      {
        label: "決戦",
        baseZ: 190,
        startDelay: 18,
        fighterWaves: 1,
        fightersPerWave: 6,
        corvettes: 3,
        battleships: true,
        waveInterval: 18,
        battleSpacing: 24
      },
      // ステージ後半に艦隊一斉出撃を詰め込むゾーン
      {
        label: "艦隊戦",
        baseZ: 205,
        startDelay: 22,
        fighterWaves: 2,
        fightersPerWave: 7,
        corvettes: 4,
        battleships: true,
        battleshipCount: 2,
        escortsPerShip: 2,
        fleetEscortRing: 2,
        fleetEscortRadius: 16,
        fleetEscortOffsetZ: 4,
        waveInterval: 14,
        battleSpacing: 22,
        message: "艦隊戦突入 - 護衛群を突破せよ"
      },
      {
        label: "旗艦",
        baseZ: 150,
        startDelay: 26,
        fighterWaves: 1,
        fightersPerWave: 6,
        corvettes: 2,
        dreadnought: true,
        dreadnoughtEscorts: 4,
        waveInterval: 14
      }
    ];

    const audioEngine = {
      ctx: null,
      noiseBuffer: null,
      lastLaserTime: 0
    };

  function init() {
  resize();
  window.addEventListener("resize", resize);
  window.addEventListener("keydown", e => {
  primeAudio();
  state.inputs[e.key.toLowerCase()] = true;
  if (!state.running && e.key.toLowerCase() === "r") resetGame();
  if (e.key === "F1") toggleDebugMode();
  });
  window.addEventListener("keyup", e => state.inputs[e.key.toLowerCase()] = false);
  window.addEventListener("pointerdown", primeAudio);
  window.addEventListener("touchstart", primeAudio, { passive: true });
  createStars();
  resetGame();
  requestAnimationFrame(loop);
  }

  function resetGame() {
  state.running = true;
  state.enemies = [];
  state.lasers = [];
  state.explosions = [];
  state.shockwaves = [];
  state.chainReactions = [];
  state.speed = 50;
  state.shield = settings.maxShield;
  state.score = 0;
  message.textContent = "";
  state.messageTimer = 0;
  state.warpPhase = "entry";
  state.warpTimer = 0;
  state.warpIntensity = 1.2;
  state.chatterTimer = 0;
  state.nextChatter = 5 + Math.random() * 3;
  state.navLog = [];
  state.warpAnnounceDone = false;
  pushComms("LAGRANGEゲート突破、機動デバイス起動");
  pushComms("旗艦ブリッジを叩け。コア露出を待つ");
  setupStage();
  }

  // 通信ログを追加し、最新数行を表示
  function pushComms(text) {
    state.navLog.push(text);
    if (state.navLog.length > 8) state.navLog.shift();
  }

  function createStars() {
  state.stars = [];
  for (let i = 0; i < settings.starCount; i++) {
  state.stars.push({
  x: (Math.random() - 0.5) * 200,
  y: (Math.random() - 0.5) * 200,
  z: Math.random() * 200 + 50
  });
  }
  }

  function setupStage() {
    // スタート時には敵を持たない状態にし、タイマーで順次湧かせる
    state.enemies = [];
    state.timeSinceStart = 0;
    state.zoneSpawnIndex = 0;
    state.running = true;
    state.formations = {};
    state.chainReactions = [];
  }

  function primeAudio() {
    // ユーザー操作が入ったら即座にAudioContextを用意
    ensureAudioContext();
  }

  function ensureAudioContext() {
    if (typeof window === "undefined") return null;
    const ctor = window.AudioContext || window.webkitAudioContext;
    if (!ctor) return null;
    if (!audioEngine.ctx) {
      audioEngine.ctx = new ctor();
      audioEngine.noiseBuffer = buildNoiseBuffer(audioEngine.ctx);
    }
    if (audioEngine.ctx.state === "suspended") {
      audioEngine.ctx.resume();
    }
    return audioEngine.ctx;
  }

  function buildNoiseBuffer(ctx) {
    const duration = 0.5;
    const buffer = ctx.createBuffer(1, ctx.sampleRate * duration, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      const decay = 1 - i / data.length;
      data[i] = (Math.random() * 2 - 1) * decay;
    }
    return buffer;
  }

  function playLaserSound() {
    const ctx = ensureAudioContext();
    if (!ctx) return;
    const now = ctx.currentTime;
    if (now - audioEngine.lastLaserTime < 0.03) return;
    audioEngine.lastLaserTime = now;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = "square";
    osc.frequency.setValueAtTime(720, now);
    osc.frequency.exponentialRampToValueAtTime(320, now + 0.12);
    gain.gain.setValueAtTime(0.23, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.14);
    osc.connect(gain).connect(ctx.destination);
    osc.start(now);
    osc.stop(now + 0.16);
  }

  function playEnemyRocketSound() {
    const ctx = ensureAudioContext();
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const now = ctx.currentTime;
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(420, now);
    osc.frequency.exponentialRampToValueAtTime(260, now + 0.18);
    gain.gain.setValueAtTime(0.16, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.22);
    const filter = ctx.createBiquadFilter();
    filter.type = "bandpass";
    filter.frequency.value = 600;
    filter.Q.value = 1.2;
    osc.connect(filter).connect(gain).connect(ctx.destination);
    osc.start(now);
    osc.stop(now + 0.24);
  }

  function playExplosionSound(power = 1) {
    const ctx = ensureAudioContext();
    if (!ctx || !audioEngine.noiseBuffer) return;
    const noise = ctx.createBufferSource();
    noise.buffer = audioEngine.noiseBuffer;
    const filter = ctx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.setValueAtTime(800 + power * 500, ctx.currentTime);
    const gain = ctx.createGain();
    const startGain = 0.32 * power;
    gain.gain.setValueAtTime(startGain, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.6);
    noise.connect(filter).connect(gain).connect(ctx.destination);
    noise.start();
    noise.stop(ctx.currentTime + 0.6);
  }

  function spawnEnemyRocket(origin, dir, options = {}) {
    // 敵弾をロケット形態に統一し、加速や残光を付与
    const speed = options.speed ?? 8;
    const accel = options.accel ?? 16;
    const maxSpeed = options.maxSpeed ?? 36;
    const rocket = {
      type: "rocket",
      x: origin.x,
      y: origin.y,
      z: origin.z,
      vx: dir.x * speed,
      vy: dir.y * speed,
      vz: dir.z * speed,
      ax: dir.x * accel,
      ay: dir.y * accel,
      az: dir.z * accel,
      maxSpeed,
      trailTimer: 0,
      color: options.color || "#f64",
      glow: options.glow || "#ff8"
    };
    state.enemyShots.push(rocket);
    playEnemyRocketSound();
  }

  function spawnRocketTrail(rocket) {
    // ロケットの残炎を粒子化して視認性を高める
    const backstep = 0.4;
    const px = rocket.x - rocket.vx * backstep * 0.02;
    const py = rocket.y - rocket.vy * backstep * 0.02;
    const pz = rocket.z - rocket.vz * backstep * 0.02;
    state.explosions.push({
      x: px,
      y: py,
      z: pz,
      vx: (Math.random() - 0.5) * 2,
      vy: (Math.random() - 0.5) * 2,
      vz: -8 + Math.random() * 3,
      life: 0.18 + Math.random() * 0.12,
      color: rocket.color || "#f64",
      width: 1.4,
      glow: rocket.glow || "#ff8",
      glowBlur: 6
    });
  }

  function showMessage(text, duration = 3) {
    message.textContent = text;
    state.messageTimer = duration;
  }

  function handleSpawnTimer() {
    while (state.zoneSpawnIndex < stageZones.length) {
      const zone = stageZones[state.zoneSpawnIndex];
      if (state.timeSinceStart < zone.startDelay) break;
      state.zoneSpawnIndex += 1;
      if (zone.message) {
        // ゾーン固有メッセージで艦隊戦などの山場を通知
        showMessage(zone.message, zone.messageDuration || 3.5);
      }
      spawnZoneFighters(zone);
      if (zone.corvettes) spawnZoneCorvettes(zone);
      if (zone.battleships) spawnZoneBattleships(zone);
      if (zone.dreadnought) spawnZoneDreadnought(zone);
    }
  }

  function updateFormationAnchors(dt) {
    const targetX = state.yaw * 3;
    const targetY = -state.pitch * 1.5;
    const anchorRetreat = settings.formationRetreatBase ?? settings.enemyRetreatBase;
    const relativeForward = state.speed - anchorRetreat;
    Object.keys(state.formations).forEach(id => {
      const formation = state.formations[id];
      formation.anchorX += (targetX - formation.anchorX) * dt * 1.6;
      formation.anchorY += (targetY - formation.anchorY) * dt * 1.2;
      if (relativeForward > 0) {
        const approach = Math.min(relativeForward, settings.maxApproachRate);
        formation.anchorZ -= approach * dt;
      } else if (relativeForward < 0) {
        const recede = Math.min(anchorRetreat, -relativeForward) * settings.enemyRecedeFactor;
        formation.anchorZ += recede * dt;
      }
      if (formation.members <= 0) {
        delete state.formations[id];
      }
    });
  }

  function releaseFormationSlot(enemy) {
    if (!enemy.formationGroup) return;
    const formation = state.formations[enemy.formationGroup];
    if (!formation) return;
    formation.members = Math.max(0, formation.members - 1);
  }

  function loopStage() {
    state.loopCount += 1;
    state.lasers = [];
    state.enemyShots = [];
    state.explosions = [];
    state.shockwaves = [];
    state.chainReactions = [];
    setupStage();
    showMessage(`STAGE MAP LOOP ${state.loopCount}`, 1.8);
  }

  function spawnZoneFighters(zone) {
    const interval = zone.waveInterval || 18;
    const perGroup = 3;
    for (let wave = 0; wave < zone.fighterWaves; wave++) {
      const waveZ = zone.baseZ - wave * interval;
      const groups = Math.ceil(zone.fightersPerWave / perGroup);
      for (let g = 0; g < groups; g++) {
        const groupId = `fg_${Date.now()}_${Math.random().toString(36).slice(2,5)}`;
        state.formations[groupId] = {
          anchorX: 0,
          anchorY: 0,
          anchorZ: waveZ,
          members: 0
        };
        for (let r = 0; r < perGroup; r++) {
          const index = g * perGroup + r;
          if (index >= zone.fightersPerWave) break;
          const offsetX = (r - 1) * 6 + (g - groups / 2) * 8;
          const offsetY = (r - 1) * 3;
          const fighter = createFighter(
            offsetX + (Math.random() - 0.5) * 4,
            offsetY + (Math.random() - 0.5) * 6,
            waveZ + (Math.random() - 0.5) * 6
          );
          fighter.formationGroup = groupId;
          fighter.formationOffset = { x: offsetX, y: offsetY };
          state.formations[groupId].members += 1;
          state.enemies.push(fighter);
        }
      }
    }
  }

  function spawnZoneCorvettes(zone) {
    const distanceStep = 6;
    for (let i = 0; i < zone.corvettes; i++) {
      const offsetX = (Math.random() - 0.5) * 30;
      const offsetY = (Math.random() - 0.5) * 20;
      const offsetZ = zone.baseZ - i * distanceStep;
      state.enemies.push(createEscort(offsetX, offsetY, offsetZ));
    }
  }

  function spawnZoneBattleships(zone) {
    const spacing = zone.battleSpacing || 22;
    const shipCount = zone.battleshipCount ?? stageConfig.battleships;
    for (let i = 0; i < shipCount; i++) {
      const lane = i - (shipCount - 1) / 2;
      const baseX = lane * 26;
      const baseY = (Math.random() - 0.5) * 32;
      const baseZ = zone.baseZ - i * spacing;
      const ship = createBattleship(baseX, baseY, baseZ);
      state.enemies.push(ship);
      const escorts = zone.escortsPerShip ?? stageConfig.escortsPerShip;
      // ゾーンごとに護衛艦の列数を増やし、後半の密度を底上げ
      for (let e = 0; e < escorts; e++) {
        const offsetX = baseX + (e % 2 === 0 ? -10 : 10);
        const offsetY = baseY + (e === 0 ? -6 : 6);
        const offsetZ = baseZ + 10 + e * 4;
        state.enemies.push(createEscort(offsetX, offsetY, offsetZ));
      }
      const ringCount = zone.fleetEscortRing ?? 0;
      if (ringCount > 0) {
        // 螺旋状の追加護衛で艦隊戦らしい包囲感を演出
        const radius = zone.fleetEscortRadius ?? 20;
        const offsetZ = zone.fleetEscortOffsetZ ?? 8;
        for (let r = 0; r < ringCount; r++) {
          const angle = (Math.PI * 2 * r) / ringCount;
          const escortX = baseX + Math.cos(angle) * radius;
          const escortY = baseY + Math.sin(angle) * radius * 0.6;
          const escortZ = baseZ + offsetZ + r * 1.1;
          const ringEscort = createEscort(escortX, escortY, escortZ);
          ringEscort.vx *= 0.4;
          ringEscort.vy *= 0.4;
          state.enemies.push(ringEscort);
        }
      }
    }
  }

  function spawnZoneDreadnought(zone) {
    const baseX = 0;
    const baseY = (Math.random() - 0.5) * 14;
    const baseZ = zone.baseZ || 150;
    const dread = createDreadnought(baseX, baseY, baseZ);
    state.enemies.push(dread);
    const escorts = zone.dreadnoughtEscorts ?? stageConfig.dreadnoughtEscorts;
    for (let i = 0; i < escorts; i++) {
      const angle = (Math.PI * 2 * i) / escorts;
      const radius = 22 + (i % 2) * 5;
      const offsetX = baseX + Math.cos(angle) * radius;
      const offsetY = baseY + Math.sin(angle) * radius * 0.6;
      const offsetZ = baseZ + 8 + i * 3;
      state.enemies.push(createEscort(offsetX, offsetY, offsetZ));
    }
    showMessage("FLAGSHIP DETECTED - DESTROY CORE", 4.5);
  }

  function createFighter(x, y, z) {
  return {
  type: "fighter",
  x: x ?? (Math.random() - 0.5) * 120,
  y: y ?? (Math.random() - 0.5) * 80,
  z: z ?? 320,
  vx: (Math.random() - 0.5) * 4,
  vy: (Math.random() - 0.5) * 4,
  retreatSpeed: settings.enemyRetreatBase + Math.random() * 6,
  maxApproachRate: settings.maxApproachRate + Math.random() * 2,
  flash: 0,
  fireTimer: Math.random() * enemyFireSettings.maxDelay,
  fireDelay: enemyFireSettings.minDelay + Math.random() * (enemyFireSettings.maxDelay - enemyFireSettings.minDelay),
  retired: false,
  pendingExplosion: false,
  pendingExplosionColor: "#f0f",
  pendingExplosionScore: 100,
  pendingMegaExplosion: false,
  megaExplosionHandler: null,
  scoreAwarded: false
  };
  }

  function createEscort(x, y, z) {
  return {
  type: "corvette",
  x,
  y,
  z,
  vx: (Math.random() - 0.5) * 3,
  vy: (Math.random() - 0.5) * 3,
  retreatSpeed: settings.enemyRetreatBase - 2 + Math.random() * 4,
  maxApproachRate: settings.maxApproachRate - 2 + Math.random() * 2,
  recedeFactor: settings.enemyRecedeFactor,
  phase: Math.random() * Math.PI * 2,
  flash: 0,
  fireTimer: Math.random() * enemyFireSettings.maxDelay,
  fireDelay: enemyFireSettings.minDelay + Math.random() * (enemyFireSettings.maxDelay - enemyFireSettings.minDelay),
  retired: false,
  pendingExplosion: false,
  pendingExplosionColor: "#0f9",
  pendingExplosionScore: 150,
  pendingMegaExplosion: false,
  megaExplosionHandler: null,
  scoreAwarded: false
  };
  }

  function createBattleship(baseX, baseY, baseZ) {
  const segments = [];
  const segmentCount = 4;
  const spacing = 16;
  for (let i = 0; i < segmentCount; i++) {
  segments.push({
  offsetX: (Math.random() - 0.5) * 4,
  offsetY: (Math.random() - 0.5) * 3,
  offsetZ: i * spacing,
  destroyed: false,
  hp: 2 + Math.floor(Math.random() * 3),
  size: i === 0 ? 11 : 9
  });
  }
  return {
  type: "battleship",
  x: baseX ?? (Math.random() - 0.5) * 100,
  y: baseY ?? (Math.random() - 0.5) * 60,
  z: baseZ ?? 340,
  retreatSpeed: 24 + Math.random() * 4,
  maxApproachRate: 26,
  recedeFactor: 0.38,
  vx: (Math.random() - 0.5) * 4,
  vy: (Math.random() - 0.5) * 3,
  flash: 0,
  segments
  ,
  fireTimer: Math.random() * enemyFireSettings.maxDelay,
  fireDelay: enemyFireSettings.minDelay + Math.random() * (enemyFireSettings.maxDelay - enemyFireSettings.minDelay),
  retired: false,
  pendingExplosion: false,
  pendingExplosionColor: "#fff",
  pendingExplosionScore: 200,
  pendingMegaExplosion: false,
  megaExplosionHandler: null,
  scoreAwarded: false,
  explosionDelay: 0,
  cumulativeDamage: 0,
  damageThreshold: segmentCount * 45
  };
  }

  function createDreadnought(baseX, baseY, baseZ) {
    const blueprint = [
      { key: "engineL", offsetX: -18, offsetY: 5, offsetZ: -24, hp: 3, size: 12, score: 200, turret: true, fireDelay: 2.8, neighbors: ["hangar", "shield"] },
      { key: "engineR", offsetX: 18, offsetY: 5, offsetZ: -24, hp: 3, size: 12, score: 200, turret: true, fireDelay: 2.8, neighbors: ["hangar", "shield"] },
      { key: "hangar", offsetX: 0, offsetY: 9, offsetZ: -8, hp: 4, size: 14, score: 260, turret: true, fireDelay: 2.4, neighbors: ["engineL", "engineR", "shield", "bridge"] },
      { key: "shield", offsetX: 0, offsetY: 0, offsetZ: -4, hp: 4, size: 15, score: 280, generator: true, neighbors: ["engineL", "engineR", "hangar", "bridge", "core"] },
      { key: "bridge", offsetX: 0, offsetY: -6, offsetZ: 10, hp: 3, size: 12, score: 320, requires: ["shield"], turret: true, fireDelay: 3.2, neighbors: ["hangar", "shield", "core"] },
      { key: "core", offsetX: 0, offsetY: 0, offsetZ: 22, hp: 5, size: 10, score: 900, requires: ["engineL", "engineR", "hangar", "bridge"], final: true, neighbors: ["bridge", "shield"] }
    ];
    const segments = blueprint.map(seg => ({
      ...seg,
      destroyed: false
    }));
    const segmentMap = {};
    for (const segment of segments) {
      segmentMap[segment.key] = segment;
    }
    return {
      type: "dreadnought",
      x: baseX ?? (Math.random() - 0.5) * 40,
      y: baseY ?? (Math.random() - 0.5) * 24,
      z: baseZ ?? 360,
      vx: 0,
      vy: 0,

      retreatSpeed: 18,
      maxApproachRate: 20,
      recedeFactor: 0.32,

      flash: 0,
      segments,
      segmentMap,
      fireTimer: 0,
      fireDelay: 3,
      turretTimers: {},
      retired: false,
      pendingExplosion: false,
      pendingExplosionColor: "#fff",
      pendingExplosionScore: 900,
      pendingMegaExplosion: false,
      megaExplosionHandler: null,
      scoreAwarded: false,
      explosionDelay: 0,
      driftPhase: Math.random() * Math.PI * 2,
      coreAnnounced: false,
      // 航空母艦らしく戦闘機を継続発艦させるための管理フラグ
      carrierTag: `carrier_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,6)}`,
      carrierLaunchTimer: 0,
      carrierLaunchInterval: 2.8,
      carrierLaunchBurst: 4,
      carrierMaxActive: 12,
      carrierLaunchAnnounced: false
    };
  }

  function handleCarrierLaunch(enemy, dt) {
    // ハンガーが健在な間は一定間隔で戦闘機を甲板から発進させる
    if (enemy.pendingExplosion) return;
    const hangar = enemy.segmentMap?.hangar;
    if (!hangar || hangar.destroyed) return;
    enemy.carrierLaunchTimer = (enemy.carrierLaunchTimer || 0) + dt;
    const interval = enemy.carrierLaunchInterval || 3.2;
    if (enemy.carrierLaunchTimer < interval) return;
    const maxActive = enemy.carrierMaxActive || 12;
    const active = countCarrierFighters(enemy);
    if (active >= maxActive) return;
    enemy.carrierLaunchTimer = 0;
    const spawnTotal = Math.min(enemy.carrierLaunchBurst || 3, maxActive - active);
    if (spawnTotal <= 0) return;
    if (!enemy.carrierLaunchAnnounced) {
      showMessage("CARRIER DECK LAUNCH - INTERCEPT", 3.2);
      enemy.carrierLaunchAnnounced = true;
    }
    for (let i = 0; i < spawnTotal; i++) {
      state.enemies.push(spawnCarrierFighter(enemy, hangar, i, spawnTotal));
    }
  }

  function countCarrierFighters(enemy) {
    const tag = enemy.carrierTag;
    if (!tag) return 0;
    let active = 0;
    for (const foe of state.enemies) {
      if (foe.type === "fighter" && foe.carrierTag === tag && !foe.retired && !foe.pendingExplosion) {
        active += 1;
      }
    }
    return active;
  }

  function spawnCarrierFighter(enemy, hangarSegment, index, total) {
    // ハンガー口から扇状に飛び出すように座標と速度を付与
    const segPos = segmentWorldPosition(enemy, hangarSegment);
    const spread = (index - (total - 1) / 2) * 4;
  const fighter = createFighter(
      segPos.x + spread + (Math.random() - 0.5) * 2.4,
      segPos.y - 2 + (Math.random() - 0.5) * 2,
      segPos.z + 8 + Math.random() * 4
    );
    fighter.carrierTag = enemy.carrierTag;
    fighter.vx += (Math.random() - 0.5) * 2;
    fighter.vy += -4 - Math.random() * 2;
    fighter.retreatSpeed = Math.max(18, fighter.retreatSpeed - 4);
    fighter.maxApproachRate += 4;
    fighter.flash = 0.35;
    fighter.carrierOrbital = true;
    fighter.orbitAngle = Math.random() * Math.PI * 2;
    fighter.orbitSpeed = 0.9 + Math.random() * 0.9;
    fighter.orbitRadius = 14 + Math.random() * 8;
    fighter.orbitHeight = 6 + Math.random() * 5;
    fighter.carrierPhase = "orbit";
    fighter.carrierPhaseTimer = 0;
    fighter.carrierOrbitDuration = 1.8 + Math.random() * 1.6;
    fighter.carrierDiveBias = Math.random() * 0.8 - 0.4;
    fighter.carrierRoll = 0;
    return fighter;
  }

  function updateCarrierInterceptor(enemy, dt) {
    // フェーズ制で周遊→急降下→上昇に遷移させて戦闘機らしい挙動を再現
    enemy.carrierPhaseTimer = (enemy.carrierPhaseTimer || 0) + dt;
    enemy.orbitAngle = (enemy.orbitAngle || 0) + dt * (enemy.orbitSpeed || 1.1);
    const baseX = state.yaw * 2.6;
    const baseY = -state.pitch * 1.4;
    const radius = enemy.orbitRadius || 16;
    const phase = enemy.carrierPhase || "orbit";
    if (phase === "orbit") {
      const desiredX = baseX + Math.cos(enemy.orbitAngle) * radius;
      const desiredY = baseY + Math.sin(enemy.orbitAngle) * radius * 0.7;
      const desiredZ = 70 + Math.sin(enemy.orbitAngle * 1.35) * (enemy.orbitHeight || 8);
      enemy.vx += (desiredX - enemy.x) * dt * 7.2;
      enemy.vy += (desiredY - enemy.y) * dt * 7.2;
      enemy.z += (desiredZ - enemy.z) * dt * 4.8;
      enemy.vx += Math.cos(enemy.orbitAngle + Math.PI / 2) * 2.4 * dt;
      enemy.vy += Math.sin(enemy.orbitAngle + Math.PI / 2) * 2.4 * dt;
      const desiredRoll = Math.sin(enemy.orbitAngle * 1.2) * 28;
      const currentRoll = enemy.carrierRoll || 0;
      enemy.carrierRoll = currentRoll + (desiredRoll - currentRoll) * dt * 2.8;
      if (enemy.carrierPhaseTimer > (enemy.carrierOrbitDuration || 2.2)) {
        enemy.carrierPhase = "dive";
        enemy.carrierPhaseTimer = 0;
      }
    } else if (phase === "dive") {
      const targetX = state.yaw * 0.6 + enemy.carrierDiveBias;
      const targetY = -state.pitch * 0.6;
      const targetZ = 22;
      enemy.vx += (targetX - enemy.x) * dt * 9.5;
      enemy.vy += (targetY - enemy.y) * dt * 9.5;
      enemy.z += (targetZ - enemy.z) * dt * 8.2;
      enemy.carrierRoll = Math.min(55, (enemy.carrierRoll || 0) + dt * 180);
      if (enemy.carrierPhaseTimer > 1.6 || enemy.z < 26) {
        enemy.carrierPhase = "climb";
        enemy.carrierPhaseTimer = 0;
      }
    } else {
      const climbTargetZ = 80;
      const lateralDrift = Math.sin(enemy.orbitAngle) * radius * 0.4;
      enemy.vx += (baseX + lateralDrift - enemy.x) * dt * 6.4;
      enemy.vy += (baseY - lateralDrift * 0.5 - enemy.y) * dt * 6.4;
      enemy.z += (climbTargetZ - enemy.z) * dt * 5.2;
      enemy.carrierRoll = Math.max(0, (enemy.carrierRoll || 0) - dt * 160);
      if (enemy.carrierPhaseTimer > 1.4) {
        enemy.carrierPhase = "orbit";
        enemy.carrierPhaseTimer = 0;
        enemy.carrierOrbitDuration = 1.6 + Math.random() * 1.8;
      }
    }
  }

  function updateFormationFighterFlight(enemy, dt, formationTarget) {
    // フォーメーション戦闘機をなめらかなバンク＆ノーズ制御で飛ばす
    const aimX = formationTarget ? formationTarget.x : state.yaw * 3.2;
    const aimY = formationTarget ? formationTarget.y : -state.pitch * 2;
    const desiredVX = (aimX - enemy.x) * 2.6;
    const desiredVY = (aimY - enemy.y) * 2.0;
    enemy.vx += (desiredVX - enemy.vx) * dt * 4.1;
    enemy.vy += (desiredVY - enemy.vy) * dt * 3.8;
    enemy.vy += Math.sin(enemy.age * 2.3) * dt * 1.4;
    const bankTarget = Math.max(-50, Math.min(50, (desiredVX - enemy.vx) * 2.2));
    const currentRoll = enemy.flightRoll || 0;
    enemy.flightRoll = currentRoll + (bankTarget - currentRoll) * dt * 5.4;
    enemy.vx += Math.cos(enemy.age * 1.2 + enemy.flightRoll * 0.05) * dt * 0.8;
  }

  function handleInput(dt) {
  // 入力状態から機体姿勢と速度を更新
  const a = state.inputs;
  const agility = a["shift"] ? settings.agilityQuick : settings.agilityBase;
  const turnSpeed = agility * dt;
  const yawDir = (a["arrowleft"] || a["a"]) ? 1 : (a["arrowright"] || a["d"]) ? -1 : 0;
  const pitchDir = (a["arrowup"] || a["w"]) ? 1 : (a["arrowdown"] || a["s"]) ? -1 : 0;
  const manualRoll = (a["q"] ? 1 : 0) - (a["e"] ? 1 : 0);
  const rollTarget = yawDir * 30 + manualRoll * 25;
  state.roll += (rollTarget - state.roll) * dt * settings.rollReturn;
  if (yawDir !== 0) {
    state.yaw += (turnSpeed + Math.abs(state.roll) * 0.005) * yawDir;
  }
  state.yaw += state.roll * settings.rollYawInfluence * dt;
  if (pitchDir !== 0) {
    state.pitch += turnSpeed * pitchDir;
  }
  if (a["shift"]) state.speed = Math.min(settings.maxSpeed, state.speed + 60 * dt);
  else if (a["control"]) state.speed = Math.max(settings.minSpeed, state.speed - 60 * dt);
  if (a[" "]) {
  fireLaser();
  a[" "] = false;
  }
  }

  function fireLaser() {
  const baseVz = state.speed + 120;
  const offsets = [-3.5, 3.5];
  offsets.forEach(offset => {
    state.lasers.push({
      x: state.yaw * 0.2 + offset,
      y: -state.pitch * 0.2,
      z: 10,
      vz: baseVz
    });
  });
  playLaserSound();
  }

  function toggleDebugMode() {
  state.debugMode = !state.debugMode;
  if (state.debugMode) {
    state.shield = settings.maxShield;
  }
  }

  function spawnExplosion(x, y, z, color, count) {
  // ワイヤーフレーム風の飛散粒子を生成（スローで余韻を強調）
  for (let i = 0; i < count; i++) {
    const speed = 18 + Math.random() * 28;
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.random() * Math.PI;
  const vx = Math.cos(theta) * Math.sin(phi) * speed;
  const vy = Math.sin(theta) * Math.sin(phi) * speed;
  const vz = Math.cos(phi) * speed * 0.7;
      state.explosions.push({
        x,
        y,
        z,
        vx,
        vy,
        vz,
        life: 0.9 + Math.random() * 0.7,
        color
      });
    }
  }

  function spawnLingeringExplosion(x, y, z, color) {
    const count = 30;
    for (let i = 0; i < count; i++) {
      const speed = 6 + Math.random() * 4;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const vx = Math.cos(theta) * Math.sin(phi) * speed * 0.2;
      const vy = Math.sin(theta) * Math.sin(phi) * speed * 0.2;
      const vz = Math.cos(phi) * speed * 0.3;
      state.explosions.push({
        x,
        y,
        z,
        vx,
        vy,
        vz,
        life: 1.2 + Math.random() * 0.6,
        color
      });
    }
  }

  function spawnShardBurst(x, y, z, color = "#fff") {
    // 小型敵爆発に鋭い破片を足してスピード感を演出
    const count = 22;
    for (let i = 0; i < count; i++) {
      const speed = 28 + Math.random() * 36;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      state.explosions.push({
        x,
        y,
        z,
        vx: Math.cos(theta) * Math.sin(phi) * speed,
        vy: Math.sin(theta) * Math.sin(phi) * speed,
        vz: Math.cos(phi) * speed * 0.6,
        life: 0.8 + Math.random() * 0.4,
        color,
        width: 2.2 + Math.random() * 1.4,
        glow: color,
        glowBlur: 8
      });
    }
  }

  function spawnShockwaveRing(x, y, z, color = "#fff") {
    // 衝撃波リングで爆心地の強さを可視化
    state.shockwaves.push({
      x,
      y,
      z,
      radius: 3,
      expansion: 42,
      life: 0.9,
      initialLife: 0.9,
      color,
      width: 4.5
    });
  }

  function spawnEnhancedEnemyExplosion(x, y, z, color = "#fff") {
    // 敵機撃破時は閃光→破片→残光の三段構えで派手さを底上げ
    playExplosionSound(0.85);
    const accent = color === "#0f9" ? "#8ff" : "#0ff";
    spawnShockwaveRing(x, y, z, "#fff");
    spawnExplosion(x, y, z, color, 24);
    spawnExplosion(x, y, z, "#fff", 12);
    spawnShardBurst(x, y, z, accent);
    spawnLingeringExplosion(x, y, z + 4, accent);
  }

  function spawnShieldSpark(x, y, z, color = "#0ff") {
    for (let i = 0; i < 14; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 20 + Math.random() * 40;
      state.explosions.push({
        x,
        y,
        z,
        vx: Math.cos(angle) * speed * 0.04,
        vy: Math.sin(angle) * speed * 0.04,
        vz: (Math.random() - 0.5) * speed * 0.08,
        life: 0.2 + Math.random() * 0.25,
        color
      });
    }
  }

  function scheduleSegmentChain(enemy, segmentKey, delay = 0.25) {
    // 旗艦の誘爆イベントを一定時間後に実行
    state.chainReactions.push({ enemy, segmentKey, timer: delay });
  }

  function triggerNeighborChain(enemy, segment) {
    // 隣接セグメントを数個だけランダムに誘爆させる
    if (!segment?.neighbors || !enemy?.segmentMap) return;
    const candidates = segment.neighbors
      .map(key => enemy.segmentMap[key])
      .filter(seg => seg && !seg.destroyed && !isSegmentLocked(enemy, seg));
    if (candidates.length === 0) return;
    const chainCount = Math.min(candidates.length, 1 + Math.floor(Math.random() * 2));
    for (let i = 0; i < chainCount; i++) {
      const index = Math.floor(Math.random() * candidates.length);
      const target = candidates.splice(index, 1)[0];
      scheduleSegmentChain(enemy, target.key, 0.25 + Math.random() * 0.25);
    }
  }

  function queueDelayedExplosion(enemy, { delay = 0.6, color = "#fff", score = 0, mega = false, megaHandler = null } = {}) {
    if (enemy.pendingExplosion) return;
    enemy.dead = true;
    enemy.pendingExplosion = true;
    enemy.explosionDelay = delay + explosionSettings.extraDelay;
    enemy.pendingExplosionColor = color;
    enemy.pendingExplosionScore = score;
    enemy.pendingMegaExplosion = Boolean(mega);
    enemy.megaExplosionHandler = megaHandler;
    enemy.flash = 0.6;
    enemy.scoreAwarded = false;
  }

  function queueBattleshipExplosion(enemy) {
    queueDelayedExplosion(enemy, { delay: 0.75, color: "#fff", score: 200, mega: true });
  }

  function queueDreadnoughtExplosion(enemy) {
    queueDelayedExplosion(enemy, { delay: 1.3, color: "#fff", score: 1200, mega: true, megaHandler: spawnDreadnoughtCataclysm });
    showMessage("FLAGSHIP NEUTRALIZED", 4.2);
  }

  function applyBattleshipSegmentDamage(enemy, segment, segPos) {
    if (segment.destroyed) return;
    segment.hp = Math.max(0, (segment.hp ?? 1) - 1);
    enemy.cumulativeDamage += 40;
    enemy.flash = 0.2;
    state.score += 120;
    spawnExplosion(segPos.x, segPos.y, segPos.z, "#0ff", segment.hp > 0 ? 10 : 20);
    if (segment.hp <= 0) {
      segment.destroyed = true;
    }
    if (enemy.cumulativeDamage >= enemy.damageThreshold && !enemy.pendingExplosion) {
      enemy.dead = true;
      queueBattleshipExplosion(enemy);
    }
  }

  function applyDreadnoughtSegmentDamage(enemy, segment, segPos) {
    if (segment.destroyed) return;
    if (isSegmentLocked(enemy, segment)) {
      spawnShieldSpark(segPos.x, segPos.y, segPos.z, "#0ff");
      enemy.flash = 0.12;
      return;
    }
    const maxScore = segment.score ?? 400;
    const partialScore = Math.max(80, Math.floor(maxScore * 0.25));
    const wasFinalHit = (segment.hp ?? 1) <= 1;
    segment.hp = Math.max(0, (segment.hp ?? 1) - 1);
    enemy.flash = 0.25;
    const color = segment.generator ? "#0ff" : segment.final ? "#fff" : "#0ff";
    spawnExplosion(segPos.x, segPos.y, segPos.z, color, wasFinalHit ? 28 : 16);
    if (segment.hp <= 0) {
      segment.destroyed = true;
      state.score += maxScore;
      spawnLingeringExplosion(segPos.x, segPos.y, segPos.z, color);
      if (segment.generator) {
        showMessage("SHIELD GENERATOR DOWN", 3.2);
      }
      if (segment.final) {
        queueDreadnoughtExplosion(enemy);
      } else {
        const core = enemy.segmentMap?.core;
        if (core && !core.destroyed && !isSegmentLocked(enemy, core) && !enemy.coreAnnounced) {
          enemy.coreAnnounced = true;
          showMessage("CORE EXPOSED - FINISH IT", 3.8);
        }
        triggerNeighborChain(enemy, segment);
      }
    } else {
      state.score += partialScore;
    }
  }

  function spawnBattleshipMegaExplosion(enemy) {
    // 爆発の粒子を多めに、ゆっくり広がるように
    playExplosionSound(1.1);
    const colorCycle = ["#fff", "#0ff", "#f88"];
    const center = { x: enemy.x, y: enemy.y, z: enemy.z };
    for (let i = 0; i < 55; i++) {
      const speed = 12 + Math.random() * 20;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const vx = Math.cos(theta) * Math.sin(phi) * speed;
      const vy = Math.sin(theta) * Math.sin(phi) * speed;
      const vz = Math.cos(phi) * speed * 0.4;
      state.explosions.push({
        x: center.x,
        y: center.y,
        z: center.z,
        vx,
        vy,
        vz,
        life: 0.8 + Math.random() * 0.8,
        color: colorCycle[i % colorCycle.length]
      });
    }
    spawnExplosion(center.x, center.y, center.z, "#fff", 20);
  }

  function spawnDreadnoughtCataclysm(enemy) {
    playExplosionSound(1.4);
    const center = { x: enemy.x, y: enemy.y, z: enemy.z };
    const ringColors = ["#fff", "#0ff", "#f88"];
    for (let ring = 0; ring < 3; ring++) {
      const count = 28 + ring * 18;
      const radius = 10 + ring * 9;
      const color = ringColors[ring % ringColors.length];
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = 28 + ring * 12 + Math.random() * 10;
        state.explosions.push({
          x: center.x + Math.cos(angle) * radius * 0.25,
          y: center.y + Math.sin(angle) * radius * 0.25,
          z: center.z + ring * 4,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          vz: (Math.random() - 0.5) * speed * 0.6,
          life: 1 + Math.random() * 1.2,
          color
        });
      }
    }
    spawnExplosion(center.x, center.y, center.z, "#fff", 40);
    spawnLingeringExplosion(center.x, center.y, center.z + 6, "#0ff");
  }

  // 敵が自機の前方にいて死角でないかを確認
  function canEnemyShoot(enemy) {
    return withinForwardConePosition(enemy);
  }

  function isEnemyVisible(enemy) {
    return isPositionVisible(enemy);
  }

  function withinForwardConePosition(position) {
    if (!position) return false;
    if (position.z < enemyFireSettings.behindThreshold) return false;
    if (Math.abs(position.x) > enemyFireSettings.blindCone) return false;
    if (Math.abs(position.y) > enemyFireSettings.verticalCone) return false;
    return true;
  }

  function isPositionVisible(position) {
    if (!position || position.z <= 10) return false;
    const proj = project(position);
    return proj.x > -40 && proj.x < canvas.width + 40 && proj.y > -40 && proj.y < canvas.height + 40;
  }

  // 後方からは発射せず、規定時間ごとにレーザーを射出
  function attemptEnemyFire(enemy, dt) {
    if (enemy.retired || enemy.pendingExplosion) return;
    if (enemy.type === "dreadnought") {
      attemptDreadnoughtFire(enemy, dt);
      return;
    }
    enemy.fireTimer += dt;
    if (enemy.fireTimer < enemy.fireDelay) return;
    enemy.fireTimer = 0;
    if (!canEnemyShoot(enemy)) return;
    if (!isEnemyVisible(enemy)) return;
    if (Math.random() > enemyFireSettings.fireChance) return;
    const dir = aimAtPlayer(enemy);
    spawnEnemyRocket({ x: enemy.x, y: enemy.y, z: enemy.z - 6 }, dir, {
      speed: 7 + Math.random() * 3,
      accel: 18,
      color: "#f64"
    });
  }

  function aimAtPlayer(enemy) {
    return aimFromPoint(enemy);
  }

  function aimFromPoint(point) {
    const dx = -point.x;
    const dy = -point.y;
    const dz = -point.z;
    const mag = Math.hypot(dx, dy, dz) || 0.0001;
    return { x: dx / mag, y: dy / mag, z: dz / mag };
  }

  function attemptDreadnoughtFire(enemy, dt) {
    enemy.turretTimers = enemy.turretTimers || {};
    for (const segment of enemy.segments) {
      if (!segment.turret || segment.destroyed) continue;
      if (isSegmentLocked(enemy, segment)) continue;
      const segPos = segmentWorldPosition(enemy, segment);
      if (!withinForwardConePosition(segPos)) continue;
      if (!isPositionVisible(segPos)) continue;
      enemy.turretTimers[segment.key] = (enemy.turretTimers[segment.key] || 0) + dt;
      const delay = segment.fireDelay || enemy.fireDelay || 3.2;
      if (enemy.turretTimers[segment.key] < delay) continue;
      enemy.turretTimers[segment.key] = Math.random() * 0.8;
      if (Math.random() > 0.85) continue;
      const dir = aimFromPoint(segPos);
      spawnEnemyRocket({ x: segPos.x, y: segPos.y, z: segPos.z - 6 }, dir, {
        speed: 6 + Math.random() * 2,
        accel: 20,
        maxSpeed: 34,
        color: "#f88",
        glow: "#fdd"
      });
    }
  }
  function resetBattleshipSegments(enemy) {
  if (!enemy.segments) return;
  enemy.segments.forEach(seg => seg.destroyed = false);
  }

  function segmentWorldPosition(enemy, segment) {
  return {
  x: enemy.x + (segment.offsetX || 0),
  y: enemy.y + (segment.offsetY || 0),
  z: enemy.z + (segment.offsetZ || 0)
  };
  }

  function isSegmentLocked(enemy, segment) {
    if (!segment?.requires || !enemy?.segmentMap) return false;
    return segment.requires.some(key => {
      const req = enemy.segmentMap[key];
      return req && !req.destroyed;
    });
  }

  // ワープ演出中の速度・姿勢・演出強度を管理
  function handleWarpPhase(dt) {
    if (state.warpPhase === "combat") {
      state.warpIntensity += (0 - state.warpIntensity) * dt * 2.4;
      return;
    }
    state.warpTimer += dt;
    const entryEnd = 2.8;
    const burnEnd = 5.4;
    if (state.warpTimer < entryEnd) {
      state.speed += (settings.maxSpeed * 0.9 - state.speed) * dt * 1.3;
      state.warpIntensity += (1.4 - state.warpIntensity) * dt * 2.2;
      state.yaw *= 0.99; // 自動安定
      state.pitch *= 0.99;
    } else if (state.warpTimer < burnEnd) {
      state.speed += (settings.maxSpeed * 1.2 - state.speed) * dt * 1.3;
      state.warpIntensity += (1.8 - state.warpIntensity) * dt * 2.0;
      if (!state.warpAnnounceDone) {
        pushComms("管制: ワープ航路焼き付き、姿勢固定");
        state.warpAnnounceDone = true;
      }
    } else {
      state.warpPhase = "combat";
      state.warpIntensity = 0.5;
      state.speed = Math.min(state.speed, settings.maxSpeed);
      pushComms("宙域突破、交戦開始");
      showMessage("OBERON SECTOR - STAGE START", 2.8);
    }
  }

  // ワープ中は入力を軽く減衰させて直進させる
  function dampenDuringWarp(dt) {
    state.roll *= Math.exp(-dt * 4);
    state.yaw *= Math.exp(-dt * 3);
    state.pitch *= Math.exp(-dt * 3);
  }

  // 無線チャッターをランダムに発生させてスペースオペラ感を演出
  function handleChatter(dt) {
    state.chatterTimer += dt;
    if (state.chatterTimer < state.nextChatter) return;
    state.chatterTimer = 0;
    state.nextChatter = 5 + Math.random() * 5;
    const lines = [
      "僚機: 視界奥に航宙戦艦、砲塔多いぞ",
      "管制: 旗艦のコアが露出寸前、仕留めろ",
      "僚機: 艦載機が上がった、編隊を崩す",
      "管制: OBERON回廊、弾薬節約を推奨",
      "僚機: ワイヤーフレームでもデカいな…"
    ];
    const pick = lines[Math.floor(Math.random() * lines.length)];
    pushComms(pick);
  }

  function update(dt) {
  if (!state.running) return;
  if (state.messageTimer > 0) {
    state.messageTimer -= dt;
    if (state.messageTimer <= 0) {
      message.textContent = "";
    }
  }
  state.timeSinceStart += dt;
  handleWarpPhase(dt);
  updateFormationAnchors(dt);
  handleSpawnTimer();
  if (state.warpPhase === "combat") handleInput(dt);
  else dampenDuringWarp(dt);
      // 星を移動させて疑似的な速度感を演出
      for (const star of state.stars) {
        star.z -= dt * state.speed * 0.6;
        if (star.z < 5) star.z += 200;
      }
      handleChatter(dt);

      // プレイヤー姿勢で敵配置もゆっくり揺らし、追われる感覚を簡易再現
      for (const enemy of state.enemies) {
        enemy.age = (enemy.age || 0) + dt;

        const isCarrierInterceptor = enemy.type === "fighter" && enemy.carrierTag;
        const retreatSpeed = enemy.retreatSpeed ?? settings.enemyRetreatBase;
        const maxApproach = enemy.maxApproachRate ?? settings.maxApproachRate;
        const recedeFactor = enemy.recedeFactor ?? settings.enemyRecedeFactor;
        if (!enemy.pendingExplosion) {
          if (isCarrierInterceptor) {
            const orbitPhase = enemy.orbitAngle || 0;
            const desiredZ = 68 + Math.sin(orbitPhase * 1.25) * 12;
            enemy.z += (desiredZ - enemy.z) * dt * 4.8;
          } else {
            const relativeForward = state.speed - retreatSpeed;
            if (relativeForward > 0) {
              const approach = Math.min(relativeForward, maxApproach);
              enemy.z -= approach * dt;
            } else if (relativeForward < 0) {
              const recede = Math.min(retreatSpeed, -relativeForward) * recedeFactor;
              enemy.z += recede * dt;
            }
          }
        }

        const formation = enemy.formationGroup ? state.formations[enemy.formationGroup] : null;
        let formationTarget = null;
        if (formation && !enemy.pendingExplosion) {
          formationTarget = {
            x: formation.anchorX + (enemy.formationOffset?.x || 0),
            y: formation.anchorY + (enemy.formationOffset?.y || 0)
          };
        }
        if (formationTarget && !enemy.pendingExplosion && !isCarrierInterceptor && enemy.type !== "fighter") {
          const dx = formationTarget.x - enemy.x;
          const dy = formationTarget.y - enemy.y;
          enemy.vx = dx * 3;
          enemy.vy = dy * 3;
        }
        enemy.x += dt * enemy.vx + state.yaw * dt * 0.4;
        enemy.y += dt * enemy.vy - state.pitch * dt * 0.4;
        if (enemy.z > 420 && !enemy.dead) {
          enemy.dead = true;
          enemy.retired = true;
          releaseFormationSlot(enemy);
          continue;
        }
        if (isCarrierInterceptor) {
          updateCarrierInterceptor(enemy, dt);
        } else if (enemy.type === "fighter") {
          updateFormationFighterFlight(enemy, dt, formationTarget);
        } else if (enemy.type === "corvette") {
          enemy.x += Math.sin(enemy.age * 1.8 + enemy.phase) * 6 * dt;
          enemy.y += Math.cos(enemy.age * 1.2 + enemy.phase) * 3 * dt;
        } else if (enemy.type === "dreadnought") {
          const sway = enemy.pendingExplosion ? 0 : 1;
          enemy.x += Math.sin(enemy.age * 0.35 + enemy.driftPhase) * dt * 8 * sway;
          enemy.y += Math.cos(enemy.age * 0.28 + enemy.driftPhase) * dt * 4 * sway;
          handleCarrierLaunch(enemy, dt);
        }
        if (enemy.pendingExplosion) {
          // 爆発までの遅延演出を進める
          enemy.explosionDelay -= dt;
          enemy.flash = Math.max(0, enemy.flash - dt);
          if (enemy.explosionDelay <= 0) {
            if (enemy.pendingMegaExplosion) {
              if (enemy.megaExplosionHandler) {
                enemy.megaExplosionHandler(enemy);
              } else {
                spawnBattleshipMegaExplosion(enemy);
              }
            } else {
              spawnEnhancedEnemyExplosion(enemy.x, enemy.y, enemy.z, enemy.pendingExplosionColor || "#fff");
            }
            if (!enemy.scoreAwarded && enemy.pendingExplosionScore) {
              state.score += enemy.pendingExplosionScore;
              enemy.scoreAwarded = true;
            }
            enemy.retired = true;
            enemy.megaExplosionHandler = null;
            releaseFormationSlot(enemy);
          }
          continue;
        }
        attemptEnemyFire(enemy, dt);
        if (enemy.z < 5 && !enemy.dead) {
          const damage = enemy.type === "dreadnought" ? 40 : enemy.type === "battleship" ? 25 : enemy.type === "corvette" ? 12 : 6;
          if (!state.debugMode) state.shield -= damage;
          enemy.dead = true;
          if (enemy.type === "dreadnought") {
            enemy.retired = true;
            releaseFormationSlot(enemy);
            spawnDreadnoughtCataclysm(enemy);
          } else {
            const color = enemy.type === "battleship" ? "#fff" : "#f44";
            queueDelayedExplosion(enemy, { delay: 0.35, color });
          }
        }
        if (enemy.flash > 0) enemy.flash -= dt;
      }

      // レーザー移動とヒット判定
      for (const laser of state.lasers) {
        laser.z += laser.vz * dt;
      }
      state.lasers = state.lasers.filter(l => l.z < 400 && !l.done);
      // 敵レーザーを移動させて自機に触れるか判定
      for (const shot of state.enemyShots) {
        if (shot.type === "rocket") {
          shot.vx += shot.ax * dt;
          shot.vy += shot.ay * dt;
          shot.vz += shot.az * dt;
          const speed = Math.hypot(shot.vx, shot.vy, shot.vz);
          const cap = shot.maxSpeed || 36;
          if (speed > cap && speed > 0) {
            const scale = cap / speed;
            shot.vx *= scale;
            shot.vy *= scale;
            shot.vz *= scale;
          }
          shot.trailTimer = (shot.trailTimer || 0) + dt;
          if (shot.trailTimer > 0.045) {
            spawnRocketTrail(shot);
            shot.trailTimer = 0;
          }
        }
        shot.x += shot.vx * dt;
        shot.y += shot.vy * dt;
        shot.z += shot.vz * dt;
        if (shot.z < 5 && !shot.done) {
          shot.done = true;
          state.shield -= 8;
          spawnExplosion(shot.x, shot.y, shot.z, "#f44", 10);
          playExplosionSound(0.4);
        }
      }
      state.enemyShots = state.enemyShots.filter(shot => shot.z > -20 && !shot.done);
      // 爆発パーティクル更新
      for (const particle of state.explosions) {
        particle.life -= dt;
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        particle.z += particle.vz * dt;
      }
      state.explosions = state.explosions.filter(p => p.life > 0);

      // 誘爆イベントを遅延実行
      const nextChains = [];
      for (const chain of state.chainReactions) {
        const remaining = chain.timer - dt;
        if (remaining <= 0) {
          const enemy = chain.enemy;
          const segment = enemy?.segmentMap?.[chain.segmentKey];
          if (enemy && !enemy.retired && segment && !segment.destroyed) {
            const segPos = segmentWorldPosition(enemy, segment);
            spawnExplosion(segPos.x, segPos.y, segPos.z, "#fdd", 14);
            applyDreadnoughtSegmentDamage(enemy, segment, segPos);
          }
        } else {
          nextChains.push({ ...chain, timer: remaining });
        }
      }
      state.chainReactions = nextChains;

      // 衝撃波の寿命と拡散を管理
      for (const wave of state.shockwaves) {
        wave.life -= dt;
        wave.radius += wave.expansion * dt;
        wave.width = Math.max(0.8, wave.width - dt * 4.5);
      }
      state.shockwaves = state.shockwaves.filter(wave => wave.life > 0);

      // 3D距離しきい値で命中判定（簡易スフィア）
      for (const enemy of state.enemies) {
        for (const laser of state.lasers) {
          if (laser.done) continue;
          if (enemy.type === "dreadnought") {
            for (const segment of enemy.segments) {
              if (segment.destroyed) continue;
              const segPos = segmentWorldPosition(enemy, segment);
              const dx = segPos.x - laser.x;
              const dy = segPos.y - laser.y;
              const dz = segPos.z - laser.z;
              if (Math.abs(dz) < 18 && Math.hypot(dx, dy) < (segment.size + 3)) {
                applyDreadnoughtSegmentDamage(enemy, segment, segPos);
                laser.done = true;
                break;
              }
            }
          } else if (enemy.type === "battleship") {
            for (const segment of enemy.segments) {
              if (segment.destroyed) continue;
              const segPos = segmentWorldPosition(enemy, segment);
              const dx = segPos.x - laser.x;
              const dy = segPos.y - laser.y;
              const dz = segPos.z - laser.z;
              if (Math.abs(dz) < 16 && Math.hypot(dx, dy) < (segment.size + 2)) {
                applyBattleshipSegmentDamage(enemy, segment, segPos);
                laser.done = true;
                break;
              }
            }
          } else if (enemy.type === "corvette") {
            const dx = enemy.x - laser.x;
            const dy = enemy.y - laser.y;
            const dz = enemy.z - laser.z;
            if (Math.abs(dz) < 14 && Math.hypot(dx, dy) < 10) {
              enemy.flash = 0.2;
            enemy.dead = true;
            queueDelayedExplosion(enemy, { delay: 0.4, color: "#0f9", score: 150 });
            laser.done = true;
          }
          } else {
            const dx = enemy.x - laser.x;
            const dy = enemy.y - laser.y;
            const dz = enemy.z - laser.z;
            if (Math.abs(dz) < 12 && Math.hypot(dx, dy) < 6) {
              enemy.flash = 0.2;
            enemy.dead = true;
            queueDelayedExplosion(enemy, { delay: 0.35, color: "#f0f", score: 100 });
            laser.done = true;
          }
        }
      }
      }

      state.enemies = state.enemies.filter(enemy => !enemy.retired);
      if (state.enemies.length === 0 && state.zoneSpawnIndex >= stageZones.length) {
        loopStage();
        return;
      }

      if (state.shield <= 0 && !state.debugMode) {
        state.running = false;
        message.textContent = "MISSION FAILED - PRESS R";
      }

  }

  function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = 1;

      // 星のスキャンライン（ワープ強度で伸ばす）
      ctx.beginPath();
      ctx.strokeStyle = state.warpPhase === "combat" ? "#0ff" : "#9ef";
      for (const star of state.stars) {
        const head = project(star);
        const tailOffset = 4 + state.warpIntensity * 18;
        const tail = project({ x: star.x, y: star.y, z: star.z + tailOffset });
        ctx.moveTo(tail.x, tail.y);
        ctx.lineTo(head.x, head.y);
      }
      ctx.stroke();

      // レーザーを細線で表示
      for (const laser of state.lasers) {
        drawPlayerLaser(laser);
      }
      // 敵ロケットの描画（視認性を高める）
      for (const shot of state.enemyShots) {
        if (shot.type === "rocket") {
          drawEnemyRocket(shot);
        } else {
          const p = project(shot);
          ctx.strokeStyle = "#f44";
          ctx.beginPath();
          ctx.moveTo(p.x - 1, p.y);
          ctx.lineTo(p.x + 1, p.y);
          ctx.stroke();
        }
      }

      // 敵ワイヤーフレーム（小型/大型）を描画
      for (const enemy of state.enemies) {
        if (enemy.type === "dreadnought") {
          drawDreadnought(enemy);
        } else if (enemy.type === "battleship") {
          drawBattleship(enemy);
        } else if (enemy.type === "corvette") {
          drawCorvette(enemy);
        } else {
          drawFighter(enemy);
        }
      }

      // 爆発パーティクルをベクタースタイルで描画
      for (const particle of state.explosions) {
        const tail = {
          x: particle.x - particle.vx * 0.015,
          y: particle.y - particle.vy * 0.015,
          z: particle.z - particle.vz * 0.015
        };
        const a = project(tail);
        const b = project(particle);
        ctx.save();
        ctx.strokeStyle = particle.color || "#fff";
        ctx.lineWidth = particle.width || 1;
        if (particle.glow) {
          ctx.shadowColor = particle.glow;
          ctx.shadowBlur = particle.glowBlur || 6;
        }
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.restore();
      }

      for (const wave of state.shockwaves) {
        drawShockwave(wave);
      }

      // コクピット枠
      ctx.strokeStyle = "#0ff";
      ctx.beginPath();
      ctx.moveTo(0, canvas.height * 0.7);
      ctx.lineTo(canvas.width * 0.3, canvas.height);
      ctx.lineTo(canvas.width * 0.7, canvas.height);
      ctx.lineTo(canvas.width, canvas.height * 0.7);
      ctx.stroke();

      drawRotatedCrosshair();

      const hudLines = [];
      const shieldText = state.debugMode ? "∞" : Math.max(state.shield, 0);
      let baseLine = `SPEED ${state.speed.toFixed(0)}   SHIELD ${shieldText}   SCORE ${state.score}`;
      if (state.debugMode) baseLine += "   DEBUG MODE";
      hudLines.push(baseLine);
      const flagship = state.enemies.find(e => e.type === "dreadnought" && !e.retired);
      if (flagship) {
        const total = flagship.segments.length;
        const destroyed = flagship.segments.filter(seg => seg.destroyed).length;
        const locked = flagship.segments.filter(seg => !seg.destroyed && isSegmentLocked(flagship, seg)).length;
        const status = flagship.pendingExplosion
          ? "SCUTTLE"
          : locked > 0
            ? `LOCK ${locked}`
            : "CORE OPEN";
        hudLines.push(`FLAGSHIP ${destroyed}/${total}   ${status}`);
      }
      hudLines.push(state.sectorLabel);
      comms.textContent = state.navLog.slice(-5).join("\n");
      hud.textContent = hudLines.join("\n");

  }

  function drawFighter(enemy) {
  const color = enemy.flash > 0 ? "#fff" : "#f0f";
  withDepthRendering(enemy, color, () => {
    const rollDeg = enemy.carrierRoll ?? enemy.flightRoll ?? 0;
    const rollRad = rollDeg * (Math.PI / 180);
    const cosR = Math.cos(rollRad);
    const sinR = Math.sin(rollRad);
    const rollPoint = (lx, ly, lz) => ({
      x: enemy.x + lx * cosR - ly * sinR,
      y: enemy.y + lx * sinR + ly * cosR,
      z: enemy.z + lz
    });
    const points = [
      rollPoint(-6, 0, 8),
      rollPoint(6, 0, 8),
      rollPoint(0, 0, -10)
    ].map(p => project(p));
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    ctx.lineTo(points[1].x, points[1].y);
    ctx.lineTo(points[2].x, points[2].y);
    ctx.closePath();
    ctx.stroke();
    ctx.beginPath();
    const leftTail = project(rollPoint(-4, -2, -4));
    ctx.moveTo(points[0].x, points[0].y);
    ctx.lineTo(leftTail.x, leftTail.y);
    ctx.stroke();
    ctx.beginPath();
    const rightTail = project(rollPoint(4, -2, -4));
    ctx.moveTo(points[1].x, points[1].y);
    ctx.lineTo(rightTail.x, rightTail.y);
    ctx.stroke();
    ctx.lineWidth = 1;
    drawWireCube({ x: enemy.x, y: enemy.y, z: enemy.z }, 5, color);
  });
  }

  function drawEnemyRocket(shot) {
    const head = project(shot);
    const tailVec = {
      x: shot.x - shot.vx * 0.12,
      y: shot.y - shot.vy * 0.12,
      z: shot.z - shot.vz * 0.12
    };
    const tail = project(tailVec);
    const sideVec = {
      x: shot.x + (shot.vy * 0.04),
      y: shot.y - (shot.vx * 0.04),
      z: shot.z
    };
    const side = project(sideVec);
    ctx.save();
    ctx.strokeStyle = shot.color || "#f64";
    ctx.fillStyle = shot.color || "#f64";
    ctx.lineWidth = 3.5;
    ctx.shadowColor = shot.glow || "#ff8";
    ctx.shadowBlur = 18;
    ctx.beginPath();
    ctx.moveTo(head.x, head.y);
    ctx.lineTo(tail.x, tail.y);
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.moveTo(head.x, head.y);
    ctx.lineTo(tail.x, tail.y);
    ctx.lineTo(side.x, side.y);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawPlayerLaser(laser) {
    const front = project(laser);
    const tail = project({ x: laser.x, y: laser.y, z: laser.z - 16 });
    ctx.save();
    ctx.strokeStyle = "#6ef";
    ctx.lineWidth = 4;
    ctx.shadowColor = "#6ef";
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.moveTo(tail.x, tail.y);
    ctx.lineTo(front.x, front.y);
    ctx.stroke();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = "#0ff";
    ctx.beginPath();
    ctx.moveTo(tail.x, tail.y);
    ctx.lineTo(front.x, front.y);
    ctx.stroke();
    ctx.fillStyle = "#9ff";
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(front.x, front.y, 3.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawShockwave(wave) {
  // 爆心地を囲むリングをスクリーン空間に投影して描画
  const alpha = Math.max(0, wave.life / wave.initialLife);
  const segments = 20;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = wave.color;
  ctx.lineWidth = wave.width;
  ctx.beginPath();
  for (let i = 0; i <= segments; i++) {
    const angle = (Math.PI * 2 * i) / segments;
    const point = project({
      x: wave.x + Math.cos(angle) * wave.radius,
      y: wave.y + Math.sin(angle) * wave.radius,
      z: wave.z
    });
    if (i === 0) ctx.moveTo(point.x, point.y);
    else ctx.lineTo(point.x, point.y);
  }
  ctx.stroke();
  ctx.restore();
  }

  function drawCorvette(enemy) {
  const color = enemy.flash > 0 ? "#fff" : "#0f9";
  withDepthRendering(enemy, color, () => {
    const hull = [];
    const length = 16;
    const width = 8;
    const height = 3;
    for (let i = 0; i < 6; i++) {
      const k = i / 5;
      hull.push({
        x: enemy.x + Math.sin(k * Math.PI) * width * 0.6,
        y: enemy.y + (i % 2 === 0 ? -height : height),
        z: enemy.z - length * (k - 0.5)
      });
    }
    ctx.beginPath();
    hull.forEach((p, idx) => {
      const proj = project(p);
      if (idx === 0) ctx.moveTo(proj.x, proj.y);
      else ctx.lineTo(proj.x, proj.y);
    });
    ctx.closePath();
    ctx.stroke();
    const bridge = project({ x: enemy.x, y: enemy.y - 2, z: enemy.z - 4 });
    const stern = project({ x: enemy.x, y: enemy.y, z: enemy.z + 6 });
    ctx.beginPath();
    ctx.moveTo(bridge.x, bridge.y);
    ctx.lineTo(stern.x, stern.y);
    ctx.stroke();
    drawWireCube({ x: enemy.x, y: enemy.y, z: enemy.z + 4 }, 4, color);
  });
  }

  function drawBattleship(enemy) {
  const color = enemy.flash > 0 ? "#fff" : "#0ff";
  withDepthRendering(enemy, color, () => {
    const hullLength = 20;
    const nose = project({ x: enemy.x, y: enemy.y, z: enemy.z - hullLength });
    const tail = project({ x: enemy.x, y: enemy.y, z: enemy.z + hullLength * 0.3 });
    ctx.beginPath();
    ctx.moveTo(nose.x, nose.y);
    ctx.lineTo(tail.x, tail.y);
    ctx.stroke();
    const wingLeft = project({ x: enemy.x - 12, y: enemy.y, z: enemy.z - 6 });
    const wingRight = project({ x: enemy.x + 12, y: enemy.y, z: enemy.z - 6 });
    ctx.beginPath();
    ctx.moveTo(wingLeft.x, wingLeft.y);
    ctx.lineTo(wingRight.x, wingRight.y);
    ctx.stroke();
    const deck = project({ x: enemy.x, y: enemy.y - 3, z: enemy.z });
    ctx.beginPath();
    ctx.arc(deck.x, deck.y, 6, 0, Math.PI * 2);
    ctx.stroke();
    const centers = [];
    for (const segment of enemy.segments) {
    if (segment.destroyed) continue;
    const pos = segmentWorldPosition(enemy, segment);
    centers.push(pos);
    drawGuideFrame(pos, segment.size || 9, color);
    }
    for (let i = 0; i < centers.length - 1; i++) {
    const a = project(centers[i]);
    const b = project(centers[i + 1]);
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
    }
  });
  }

  function drawDreadnought(enemy) {
  const color = enemy.flash > 0 ? "#fff" : "#0ff";
  withDepthRendering(enemy, color, () => {
    const prow = project({ x: enemy.x, y: enemy.y - 6, z: enemy.z - 34 });
    const stern = project({ x: enemy.x, y: enemy.y + 4, z: enemy.z + 22 });
    ctx.beginPath();
    ctx.moveTo(prow.x, prow.y);
    ctx.lineTo(stern.x, stern.y);
    ctx.stroke();
    const hullLeft = project({ x: enemy.x - 24, y: enemy.y + 6, z: enemy.z - 6 });
    const hullRight = project({ x: enemy.x + 24, y: enemy.y + 6, z: enemy.z - 6 });
    ctx.beginPath();
    ctx.moveTo(hullLeft.x, hullLeft.y);
    ctx.lineTo(prow.x, prow.y);
    ctx.lineTo(hullRight.x, hullRight.y);
    ctx.stroke();
    const keelLeft = project({ x: enemy.x - 18, y: enemy.y + 2, z: enemy.z + 12 });
    const keelRight = project({ x: enemy.x + 18, y: enemy.y + 2, z: enemy.z + 12 });
    ctx.beginPath();
    ctx.moveTo(keelLeft.x, keelLeft.y);
    ctx.lineTo(stern.x, stern.y);
    ctx.lineTo(keelRight.x, keelRight.y);
    ctx.stroke();
    const intactSegments = [];
    for (const segment of enemy.segments) {
      if (segment.destroyed) continue;
      const segPos = segmentWorldPosition(enemy, segment);
      const locked = isSegmentLocked(enemy, segment);
      const segColor = locked ? "#066" : color;
      drawGuideFrame(segPos, segment.size || 12, segColor);
      if (segment.final && !locked) {
        const center = project(segPos);
        const cross = (segment.size || 10) * 0.6;
        ctx.beginPath();
        ctx.moveTo(center.x - cross, center.y);
        ctx.lineTo(center.x + cross, center.y);
        ctx.moveTo(center.x, center.y - cross);
        ctx.lineTo(center.x, center.y + cross);
        ctx.stroke();
      }
      intactSegments.push({ pos: segPos, locked });
    }
    for (let i = 0; i < intactSegments.length - 1; i++) {
      const a = project(intactSegments[i].pos);
      const b = project(intactSegments[i + 1].pos);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }
  });
  }

  function drawGuideFrame(center, size, color) {
  drawWireCube(center, size, color);
  ctx.strokeStyle = color;
  ctx.beginPath();
  const left = project({ x: center.x - size * 0.6, y: center.y, z: center.z });
  const right = project({ x: center.x + size * 0.6, y: center.y, z: center.z });
  ctx.moveTo(left.x, left.y);
  ctx.lineTo(right.x, right.y);
  ctx.stroke();
  ctx.beginPath();
  const top = project({ x: center.x, y: center.y - size * 0.5, z: center.z });
  const bottom = project({ x: center.x, y: center.y + size * 0.5, z: center.z });
  ctx.moveTo(top.x, top.y);
  ctx.lineTo(bottom.x, bottom.y);
  ctx.stroke();
  }

  function drawWireCube(center, size, color) {
  const s = size;
  const verts = [
  [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
  [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]
  ].map(v => ({ x: center.x + v[0], y: center.y + v[1], z: center.z + v[2] }));
  drawWireShape(verts, [
  [0,1],[1,2],[2,3],[3,0],
  [4,5],[5,6],[6,7],[7,4],
  [0,4],[1,5],[2,6],[3,7]
  ], color);
  }

  function drawWireShape(verts, edges, color) {
  ctx.strokeStyle = color;
  ctx.beginPath();
  edges.forEach(([a,b]) => {
  const pa = project(verts[a]);
  const pb = project(verts[b]);
  ctx.moveTo(pa.x, pa.y);
  ctx.lineTo(pb.x, pb.y);
  });
  ctx.stroke();
  }

  function project(point) {
  // 3D座標→2D投影: x/z・y/z比に視野角を掛けてスクリーン中央に足す
  const scale = settings.fov / (point.z || 0.0001);
  return {
  x: canvas.width / 2 + point.x * scale,
  y: canvas.height / 2 + point.y * scale
  };
  }

  function depthEffect(enemy) {
  const depth = Math.min(420, Math.max(enemy.z, 20));
  const normalized = (depth - 20) / 400;
  const factor = 1 - normalized;
  const alpha = Math.min(1, Math.max(0.25, 0.35 + factor * 0.65));
  const width = 0.5 + factor * 1.8;
  return { alpha, width };
  }

  function withDepthRendering(enemy, color, drawFn) {
  const effect = depthEffect(enemy);
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = effect.width;
  ctx.globalAlpha = effect.alpha;
  drawFn();
  ctx.restore();
  }

  function drawRotatedCrosshair() {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const angle = -state.roll * settings.rollVisualFactor * Math.PI / 180;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-20, 0);
    ctx.lineTo(-5, 0);
    ctx.moveTo(20, 0);
    ctx.lineTo(5, 0);
    ctx.moveTo(0, -20);
    ctx.lineTo(0, -5);
    ctx.moveTo(0, 20);
    ctx.lineTo(0, 5);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  function loop(timestamp) {
  if (!state.lastTime) state.lastTime = timestamp;
  const dt = Math.min(0.033, (timestamp - state.lastTime) / 1000);
  state.lastTime = timestamp;
  update(dt);
  render();
  requestAnimationFrame(loop);
  }

  function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  }

  init();
  })();
  </script>
  </body>
  </html>

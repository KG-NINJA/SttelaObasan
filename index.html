<!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="UTF-8">
  <title>Stella Obasan: Vector Patrol</title>
  <style>
    html,body { margin:0; background:#000; color:#0ff; font-family:"Courier New",monospace; }
    canvas { display:block; width:100vw; height:100vh; }
    #overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:#0ff; }
    #hud { position:absolute; bottom:12px; left:12px; font-size:14px; line-height:1.4; }
    #message { position:absolute; top:40%; width:100%; text-align:center; font-size:32px; letter-spacing:4px; }
  </style>
  </head>
  <body>
  <canvas id="screen"></canvas>
  <div id="overlay">
    <div id="hud"></div>
    <div id="message"></div>
  </div>
  <script>
  (() => {
    const canvas = document.getElementById("screen");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hud");
    const message = document.getElementById("message");
    const state = {
      running: true,
      enemies: [],
      lasers: [],
      stars: [],
      inputs: {},
      speed: 50,
      shield: 100,
      score: 0,
      roll: 0,
      yaw: 0,
      pitch: 0,
      lastTime: 0
    };
    const settings = {
      starCount: 120,
      fov: 400,
      spawnInterval: 1.5,
      enemySpeed: 24,
      maxShield: 100,
      minSpeed: 20,
      maxSpeed: 120
    };
    let spawnTimer = 0;

  function init() {
  resize();
  window.addEventListener("resize", resize);
  window.addEventListener("keydown", e => {
  state.inputs[e.key.toLowerCase()] = true;
  if (!state.running && e.key.toLowerCase() === "r") resetGame();
  });
  window.addEventListener("keyup", e => state.inputs[e.key.toLowerCase()] = false);
  createStars();
  requestAnimationFrame(loop);
  }

  function resetGame() {
  state.running = true;
  state.enemies = [];
  state.lasers = [];
  state.speed = 50;
  state.shield = settings.maxShield;
  state.score = 0;
  message.textContent = "";
  }

  function createStars() {
  state.stars = [];
  for (let i = 0; i < settings.starCount; i++) {
  state.stars.push({
  x: (Math.random() - 0.5) * 200,
  y: (Math.random() - 0.5) * 200,
  z: Math.random() * 200 + 50
  });
  }
  }

  function spawnEnemy() {
  const battleshipHeavy = 0.75;
  if (Math.random() < battleshipHeavy) {
  state.enemies.push(createBattleship());
  } else {
  state.enemies.push(createFighter());
  }
  }

  function createFighter() {
  return {
  type: "fighter",
  x: (Math.random() - 0.5) * 120,
  y: (Math.random() - 0.5) * 80,
  z: 320,
  vx: (Math.random() - 0.5) * 6,
  vy: (Math.random() - 0.5) * 5,
  flash: 0
  };
  }

  function createBattleship() {
  const segments = [];
  const segmentCount = 4;
  const spacing = 16;
  for (let i = 0; i < segmentCount; i++) {
  segments.push({
  offsetX: (Math.random() - 0.5) * 4,
  offsetY: (Math.random() - 0.5) * 3,
  offsetZ: i * spacing,
  destroyed: false,
  size: i === 0 ? 11 : 9
  });
  }
  return {
  type: "battleship",
  x: (Math.random() - 0.5) * 100,
  y: (Math.random() - 0.5) * 60,
  z: 340,
  vx: (Math.random() - 0.5) * 4,
  vy: (Math.random() - 0.5) * 3,
  flash: 0,
  segments
  };
  }

  function handleInput(dt) {
  // 入力状態から機体姿勢と速度を更新
  const a = state.inputs;
  const turnSpeed = 40 * dt;
  if (a["arrowleft"] || a["a"]) state.yaw += turnSpeed;
  if (a["arrowright"] || a["d"]) state.yaw -= turnSpeed;
  if (a["arrowup"] || a["w"]) state.pitch += turnSpeed;
  if (a["arrowdown"] || a["s"]) state.pitch -= turnSpeed;
  if (a["q"]) state.roll += turnSpeed;
  if (a["e"]) state.roll -= turnSpeed;
  if (a["shift"]) state.speed = Math.min(settings.maxSpeed, state.speed + 60 * dt);
  else if (a["control"]) state.speed = Math.max(settings.minSpeed, state.speed - 60 * dt);
  if (a[" "]) {
  fireLaser();
  a[" "] = false;
  }
  }

  function fireLaser() {
  state.lasers.push({ x: state.yaw * 0.2, y: -state.pitch * 0.2, z: 10, vz: state.speed + 120 });
  }

  function resetBattleshipSegments(enemy) {
  if (!enemy.segments) return;
  enemy.segments.forEach(seg => seg.destroyed = false);
  }

  function segmentWorldPosition(enemy, segment) {
  return {
  x: enemy.x + (segment.offsetX || 0),
  y: enemy.y + (segment.offsetY || 0),
  z: enemy.z + (segment.offsetZ || 0)
  };
  }

  function update(dt) {
  if (!state.running) return;
  handleInput(dt);
  spawnTimer -= dt;
  if (spawnTimer <= 0) {
  spawnEnemy();
  spawnTimer = settings.spawnInterval;
  }

      // 星を移動させて疑似的な速度感を演出
      for (const star of state.stars) {
        star.z -= dt * state.speed * 0.6;
        if (star.z < 5) star.z += 200;
      }

      // プレイヤー姿勢で敵配置もゆっくり揺らし、追われる感覚を簡易再現
      for (const enemy of state.enemies) {
        enemy.z -= dt * (settings.enemySpeed + state.speed * 0.5);
        enemy.x += dt * enemy.vx + state.yaw * dt * 0.5;
        enemy.y += dt * enemy.vy - state.pitch * dt * 0.5;
        if (enemy.z < 5) {
          state.shield -= enemy.type === "battleship" ? 15 : 8;
          enemy.z = 420;
          if (enemy.segments) resetBattleshipSegments(enemy);
        }
        if (enemy.flash > 0) enemy.flash -= dt;
      }

      // レーザー移動とヒット判定
      for (const laser of state.lasers) {
        laser.z += laser.vz * dt;
      }
      state.lasers = state.lasers.filter(l => l.z < 400 && !l.done);

      // 3D距離しきい値で命中判定（簡易スフィア）
      for (const enemy of state.enemies) {
        for (const laser of state.lasers) {
          if (laser.done) continue;
          if (enemy.type === "battleship") {
            for (const segment of enemy.segments) {
              if (segment.destroyed) continue;
              const segPos = segmentWorldPosition(enemy, segment);
              const dx = segPos.x - laser.x;
              const dy = segPos.y - laser.y;
              const dz = segPos.z - laser.z;
              if (Math.abs(dz) < 16 && Math.hypot(dx, dy) < (segment.size + 2)) {
                segment.destroyed = true;
                enemy.flash = 0.2;
                state.score += 120;
                laser.done = true;
                break;
              }
            }
            if (enemy.segments.every(seg => seg.destroyed)) {
              enemy.z = 420 + Math.random() * 120;
              resetBattleshipSegments(enemy);
              state.score += 200; // 艦撃破ボーナス
            }
          } else {
            const dx = enemy.x - laser.x;
            const dy = enemy.y - laser.y;
            const dz = enemy.z - laser.z;
            if (Math.abs(dz) < 12 && Math.hypot(dx, dy) < 6) {
              enemy.flash = 0.2;
              enemy.z = 420 + Math.random() * 120;
              state.score += 100;
              laser.done = true;
            }
          }
        }
      }

      if (state.shield <= 0) {
        state.running = false;
        message.textContent = "MISSION FAILED - PRESS R";
      }

  }

  function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = 1;

      // 星のスキャンライン
      ctx.beginPath();
      for (const star of state.stars) {
        const p = project(star);
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + 1, p.y + 1);
      }
      ctx.stroke();

      // レーザーを細線で表示
      ctx.strokeStyle = "#0f0";
      for (const laser of state.lasers) {
        const p = project(laser);
        ctx.beginPath();
        ctx.moveTo(p.x - 2, p.y);
        ctx.lineTo(p.x + 2, p.y);
        ctx.stroke();
      }

      // 敵ワイヤーフレーム（小型/大型）を描画
      for (const enemy of state.enemies) {
        if (enemy.type === "battleship") {
          drawBattleship(enemy);
        } else {
          drawFighter(enemy);
        }
      }

      // コクピット枠
      ctx.strokeStyle = "#0ff";
      ctx.beginPath();
      ctx.moveTo(0, canvas.height * 0.7);
      ctx.lineTo(canvas.width * 0.3, canvas.height);
      ctx.lineTo(canvas.width * 0.7, canvas.height);
      ctx.lineTo(canvas.width, canvas.height * 0.7);
      ctx.stroke();

      // 中央レティクル
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, 12, 0, Math.PI * 2);
      ctx.moveTo(canvas.width / 2 - 20, canvas.height / 2);
      ctx.lineTo(canvas.width / 2 - 5, canvas.height / 2);
      ctx.moveTo(canvas.width / 2 + 5, canvas.height / 2);
      ctx.lineTo(canvas.width / 2 + 20, canvas.height / 2);
      ctx.moveTo(canvas.width / 2, canvas.height / 2 - 20);
      ctx.lineTo(canvas.width / 2, canvas.height / 2 - 5);
      ctx.moveTo(canvas.width / 2, canvas.height / 2 + 5);
      ctx.lineTo(canvas.width / 2, canvas.height / 2 + 20);
      ctx.stroke();

      hud.textContent = `SPEED ${state.speed.toFixed(0)}   SHIELD ${Math.max(state.shield,0)}   SCORE ${state.score}`;

  }

  function drawFighter(enemy) {
  drawWireCube({ x: enemy.x, y: enemy.y, z: enemy.z }, 6, enemy.flash > 0 ? "#fff" : "#f0f");
  }

  function drawBattleship(enemy) {
  const color = enemy.flash > 0 ? "#fff" : "#0ff";
  const centers = [];
  for (const segment of enemy.segments) {
  if (segment.destroyed) continue;
  const pos = segmentWorldPosition(enemy, segment);
  centers.push(pos);
  drawWireCube(pos, segment.size || 9, color);
  }
  if (centers.length > 1) {
  ctx.strokeStyle = color;
  ctx.beginPath();
  for (let i = 0; i < centers.length - 1; i++) {
  const a = project(centers[i]);
  const b = project(centers[i + 1]);
  ctx.moveTo(a.x, a.y);
  ctx.lineTo(b.x, b.y);
  }
  ctx.stroke();
  }
  }

  function drawWireCube(center, size, color) {
  const s = size;
  const verts = [
  [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
  [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]
  ].map(v => ({ x: center.x + v[0], y: center.y + v[1], z: center.z + v[2] }));
  drawWireShape(verts, [
  [0,1],[1,2],[2,3],[3,0],
  [4,5],[5,6],[6,7],[7,4],
  [0,4],[1,5],[2,6],[3,7]
  ], color);
  }

  function drawWireShape(verts, edges, color) {
  ctx.strokeStyle = color;
  ctx.beginPath();
  edges.forEach(([a,b]) => {
  const pa = project(verts[a]);
  const pb = project(verts[b]);
  ctx.moveTo(pa.x, pa.y);
  ctx.lineTo(pb.x, pb.y);
  });
  ctx.stroke();
  }

  function project(point) {
  // 3D座標→2D投影: x/z・y/z比に視野角を掛けてスクリーン中央に足す
  const scale = settings.fov / (point.z || 0.0001);
  return {
  x: canvas.width / 2 + point.x * scale,
  y: canvas.height / 2 + point.y * scale
  };
  }

  function loop(timestamp) {
  if (!state.lastTime) state.lastTime = timestamp;
  const dt = Math.min(0.033, (timestamp - state.lastTime) / 1000);
  state.lastTime = timestamp;
  update(dt);
  render();
  requestAnimationFrame(loop);
  }

  function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  }

  init();
  })();
  </script>
  </body>
  </html>

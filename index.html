<!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="UTF-8">
  <title>Stella Obasan: Vector Patrol</title>
  <style>
    html,body { margin:0; background:#000; color:#0ff; font-family:"Courier New",monospace; }
    canvas { display:block; width:100vw; height:100vh; }
    #overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:#0ff; }
    #hud { position:absolute; bottom:12px; left:12px; font-size:14px; line-height:1.4; }
    #message { position:absolute; top:40%; width:100%; text-align:center; font-size:32px; letter-spacing:4px; }
  </style>
  </head>
  <body>
  <canvas id="screen"></canvas>
  <div id="overlay">
    <div id="hud"></div>
    <div id="message"></div>
  </div>
  <script>
  (() => {
    const canvas = document.getElementById("screen");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hud");
    const message = document.getElementById("message");
    const state = {
      running: true,
      enemies: [],
      lasers: [],
      stars: [],
      inputs: {},
      speed: 50,
      shield: 100,
      score: 0,
      roll: 0,
      yaw: 0,
      pitch: 0,
      lastTime: 0
    };
    const settings = {
      starCount: 120,
      fov: 400,
      spawnInterval: 1.2,
      enemySpeed: 30,
      maxShield: 100,
      minSpeed: 20,
      maxSpeed: 120
    };
    let spawnTimer = 0;

  function init() {
  resize();
  window.addEventListener("resize", resize);
  window.addEventListener("keydown", e => {
  state.inputs[e.key.toLowerCase()] = true;
  if (!state.running && e.key.toLowerCase() === "r") resetGame();
  });
  window.addEventListener("keyup", e => state.inputs[e.key.toLowerCase()] = false);
  createStars();
  requestAnimationFrame(loop);
  }

  function resetGame() {
  state.running = true;
  state.enemies = [];
  state.lasers = [];
  state.speed = 50;
  state.shield = settings.maxShield;
  state.score = 0;
  message.textContent = "";
  }

  function createStars() {
  state.stars = [];
  for (let i = 0; i < settings.starCount; i++) {
  state.stars.push({
  x: (Math.random() - 0.5) * 200,
  y: (Math.random() - 0.5) * 200,
  z: Math.random() * 200 + 50
  });
  }
  }

  function spawnEnemy() {
  state.enemies.push({
  x: (Math.random() - 0.5) * 120,
  y: (Math.random() - 0.5) * 80,
  z: 300,
  vx: (Math.random() - 0.5) * 10,
  vy: (Math.random() - 0.5) * 8,
  flash: 0
  });
  }

  function handleInput(dt) {
  const a = state.inputs;
  const turnSpeed = 40 * dt;
  if (a["arrowleft"] || a["a"]) state.yaw += turnSpeed;
  if (a["arrowright"] || a["d"]) state.yaw -= turnSpeed;
  if (a["arrowup"] || a["w"]) state.pitch += turnSpeed;
  if (a["arrowdown"] || a["s"]) state.pitch -= turnSpeed;
  if (a["q"]) state.roll += turnSpeed;
  if (a["e"]) state.roll -= turnSpeed;
  if (a["shift"]) state.speed = Math.min(settings.maxSpeed, state.speed + 60 * dt);
  else if (a["control"]) state.speed = Math.max(settings.minSpeed, state.speed - 60 * dt);
  if (a[" "]) {
  fireLaser();
  a[" "] = false;
  }
  }

  function fireLaser() {
  state.lasers.push({ x: state.yaw * 0.2, y: -state.pitch * 0.2, z: 10, vz: state.speed + 120 });
  }

  function update(dt) {
  if (!state.running) return;
  handleInput(dt);
  spawnTimer -= dt;
  if (spawnTimer <= 0) {
  spawnEnemy();
  spawnTimer = settings.spawnInterval;
  }

      // Move stars based on player speed to sell motion
      for (const star of state.stars) {
        star.z -= dt * state.speed * 0.6;
        if (star.z < 5) star.z += 200;
      }

      // Player rotation influences enemy positions for pseudo movement
      for (const enemy of state.enemies) {
        enemy.z -= dt * (settings.enemySpeed + state.speed * 0.5);
        enemy.x += dt * enemy.vx + state.yaw * dt * 0.5;
        enemy.y += dt * enemy.vy - state.pitch * dt * 0.5;
        if (enemy.z < 5) {
          state.shield -= 20;
          enemy.z = 400;
        }
        if (enemy.flash > 0) enemy.flash -= dt;
      }

      // Update lasers and check hits
      for (const laser of state.lasers) {
        laser.z += laser.vz * dt;
      }
      state.lasers = state.lasers.filter(l => l.z < 400);

      // Collision detection via distance in projected space
      for (const enemy of state.enemies) {
        for (const laser of state.lasers) {
          const dx = enemy.x - laser.x;
          const dy = enemy.y - laser.y;
          const dz = enemy.z - laser.z;
          if (Math.abs(dz) < 10 && Math.hypot(dx, dy) < 6) {
            enemy.flash = 0.2;
            enemy.z = 400 + Math.random() * 100;
            state.score += 100;
          }
        }
      }

      if (state.shield <= 0) {
        state.running = false;
        message.textContent = "MISSION FAILED - PRESS R";
      }

  }

  function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = 1;

      // Draw stars
      ctx.beginPath();
      for (const star of state.stars) {
        const p = project(star);
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + 1, p.y + 1);
      }
      ctx.stroke();

      // Draw lasers
      ctx.strokeStyle = "#0f0";
      for (const laser of state.lasers) {
        const p = project(laser);
        ctx.beginPath();
        ctx.moveTo(p.x - 2, p.y);
        ctx.lineTo(p.x + 2, p.y);
        ctx.stroke();
      }

      // Draw enemies wireframe cube
      ctx.strokeStyle = "#f0f";
      for (const enemy of state.enemies) {
        const size = 6;
        const verts = [
          [-size, -size, -size], [size, -size, -size], [size, size, -size], [-size, size, -size],
          [-size, -size, size], [size, -size, size], [size, size, size], [-size, size, size]
        ].map(v => ({ x: enemy.x + v[0], y: enemy.y + v[1], z: enemy.z + v[2] }));
        drawWireCube(verts, enemy.flash > 0 ? "#fff" : "#f0f");
      }

      // Cockpit frame
      ctx.strokeStyle = "#0ff";
      ctx.beginPath();
      ctx.moveTo(0, canvas.height * 0.7);
      ctx.lineTo(canvas.width * 0.3, canvas.height);
      ctx.lineTo(canvas.width * 0.7, canvas.height);
      ctx.lineTo(canvas.width, canvas.height * 0.7);
      ctx.stroke();

      // Reticle
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, 12, 0, Math.PI * 2);
      ctx.moveTo(canvas.width / 2 - 20, canvas.height / 2);
      ctx.lineTo(canvas.width / 2 - 5, canvas.height / 2);
      ctx.moveTo(canvas.width / 2 + 5, canvas.height / 2);
      ctx.lineTo(canvas.width / 2 + 20, canvas.height / 2);
      ctx.moveTo(canvas.width / 2, canvas.height / 2 - 20);
      ctx.lineTo(canvas.width / 2, canvas.height / 2 - 5);
      ctx.moveTo(canvas.width / 2, canvas.height / 2 + 5);
      ctx.lineTo(canvas.width / 2, canvas.height / 2 + 20);
      ctx.stroke();

      hud.textContent = `SPEED ${state.speed.toFixed(0)}   SHIELD ${Math.max(state.shield,0)}   SCORE ${state.score}`;

  }

  function drawWireCube(verts, color) {
  const edges = [
  [0,1],[1,2],[2,3],[3,0],
  [4,5],[5,6],[6,7],[7,4],
  [0,4],[1,5],[2,6],[3,7]
  ];
  ctx.strokeStyle = color;
  ctx.beginPath();
  edges.forEach(([a,b]) => {
  const pa = project(verts[a]);
  const pb = project(verts[b]);
  ctx.moveTo(pa.x, pa.y);
  ctx.lineTo(pb.x, pb.y);
  });
  ctx.stroke();
  }

  function project(point) {
  // 3D座標→2D投影: x/z・y/z比に視野角を掛けてスクリーン中央に足す
  const scale = settings.fov / (point.z || 0.0001);
  return {
  x: canvas.width / 2 + point.x * scale,
  y: canvas.height / 2 + point.y * scale
  };
  }

  function loop(timestamp) {
  if (!state.lastTime) state.lastTime = timestamp;
  const dt = Math.min(0.033, (timestamp - state.lastTime) / 1000);
  state.lastTime = timestamp;
  update(dt);
  render();
  requestAnimationFrame(loop);
  }

  function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  }

  init();
  })();
  </script>
  </body>
  </html>
